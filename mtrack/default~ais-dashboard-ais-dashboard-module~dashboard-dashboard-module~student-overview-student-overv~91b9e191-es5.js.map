{"version":3,"sources":["./node_modules/highcharts/highcharts-3d.src.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;AACb;AACA,QAAQ,KAA0B;AAClC;AACA;AACA,KAAK,UAAU,IAA0C;AACzD,QAAQ,iCAAmC,CAAC,gFAAY,CAAC,mCAAE;AAC3D;AACA;AACA;AACA,SAAS;AAAA,oGAAC;AACV,KAAK,MAAM,EAEN;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,mBAAmB,OAAO;AAC1B;AACA,mBAAmB,OAAO;AAC1B;AACA,mBAAmB,4BAA4B;AAC/C;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mCAAmC;AACtD;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8BAA8B;AACjD;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iCAAiC;AACpD;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mCAAmC;AACtD;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uBAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mCAAmC;AACrE,kCAAkC,mCAAmC;AACrE,kCAAkC,mCAAmC;AACrE,oCAAoC,uCAAuC;AAC3E,oCAAoC,uCAAuC;AAC3E;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,eAAe;AAChD,iCAAiC,eAAe;AAChD,+BAA+B,eAAe;AAC9C,+BAA+B,eAAe;AAC9C,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA,0BAA0B;AAC1B,6CAA6C;AAC7C;AACA,0BAA0B;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,qCAAqC;AACrC,6BAA6B;AAC7B,qBAAqB;AACrB,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,kGAAkG;AAClG;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iBAAiB,sBAAsB;AACvC,iBAAiB,sBAAsB;AACvC,iBAAiB,sBAAsB;AACvC,iBAAiB;AACjB;AACA,iBAAiB,sBAAsB;AACvC,iBAAiB,sBAAsB;AACvC,iBAAiB,sBAAsB;AACvC,iBAAiB;AACjB;AACA,iBAAiB,sBAAsB;AACvC,iBAAiB,sBAAsB;AACvC,iBAAiB,sBAAsB;AACvC,iBAAiB;AACjB;AACA,iBAAiB,sBAAsB;AACvC,iBAAiB,sBAAsB;AACvC,iBAAiB,sBAAsB;AACvC,iBAAiB;AACjB;AACA,iBAAiB,sBAAsB;AACvC,iBAAiB,sBAAsB;AACvC,iBAAiB,sBAAsB;AACvC,iBAAiB;AACjB;AACA,iBAAiB,sBAAsB;AACvC,iBAAiB,sBAAsB;AACvC,iBAAiB,sBAAsB;AACvC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA,mCAAmC,oBAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wBAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sBAAsB,mBAAmB,EAAE;AAC5E,kCAAkC,sBAAsB,mBAAmB;AAC3E,qBAAqB;AACrB;AACA,gCAAgC,sBAAsB,mBAAmB,EAAE;AAC3E,mCAAmC,sBAAsB,mBAAmB;AAC5E,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAmB;AACpD,iCAAiC;AACjC,yBAAyB;AACzB;AACA;AACA;AACA;AACA,iCAAiC,mBAAmB;AACpD,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,sBAAsB;AACtB,gCAAgC;AAChC;AACA,sBAAsB;AACtB,gCAAgC;AAChC;AACA,sBAAsB;AACtB,gCAAgC;AAChC;AACA,sBAAsB;AACtB;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,cAAc;AAC/D,+CAA+C,YAAY;AAC3D;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA,mBAAmB,4BAA4B;AAC/C;AACA,mBAAmB,QAAQ;AAC3B;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,8BAA8B,2BAA2B;AACzD,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,4BAA4B;AAC5B;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,kCAAkC;AAClC,4BAA4B;AAC5B;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kCAAkC;AAClC,4BAA4B;AAC5B;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,uCAAuC;AACvC,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,yBAAyB;AACzB;AACA,8BAA8B;AAC9B,yBAAyB;AACzB;AACA,uCAAuC;AACvC,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,sBAAsB;AACtB,8CAA8C;AAC9C;AACA,sBAAsB;AACtB;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,mCAAmC,iCAAiC;AACpE;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ,gBAAgB,QAAQ,gBAAgB,QAAQ;AAC7F;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA,oBAAoB,WAAW;AAC/B;AACA,oBAAoB,WAAW;AAC/B;AACA,oBAAoB,WAAW;AAC/B;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,WAAW;;AAEX,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,YAAY;AACpD;AACA;AACA,qBAAqB;AACrB;AACA;AACA,0CAA0C,YAAY;AACtD;AACA;AACA,qBAAqB;AACrB;AACA;AACA,wCAAwC,YAAY;AACpD;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;;AAEA,KAAK;AACL;;;AAGA,KAAK;AACL,CAAC,G","file":"default~ais-dashboard-ais-dashboard-module~dashboard-dashboard-module~student-overview-student-overv~91b9e191-es5.js","sourcesContent":["/**\n * @license Highcharts JS v8.0.0 (2019-12-10)\n *\n * 3D features for Highcharts JS\n *\n * License: www.highcharts.com/license\n */\n'use strict';\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/highcharts-3d', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n        }\n    }\n    _registerModule(_modules, 'parts-3d/Math.js', [_modules['parts/Globals.js'], _modules['parts/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  (c) 2010-2019 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var pick = U.pick;\n        // Mathematical Functionility\n        var deg2rad = H.deg2rad;\n        /* eslint-disable max-len */\n        /**\n         * Apply 3-D rotation\n         * Euler Angles (XYZ):\n         *     cosA = cos(Alfa|Roll)\n         *     cosB = cos(Beta|Pitch)\n         *     cosG = cos(Gamma|Yaw)\n         *\n         * Composite rotation:\n         * |          cosB * cosG             |           cosB * sinG            |    -sinB    |\n         * | sinA * sinB * cosG - cosA * sinG | sinA * sinB * sinG + cosA * cosG | sinA * cosB |\n         * | cosA * sinB * cosG + sinA * sinG | cosA * sinB * sinG - sinA * cosG | cosA * cosB |\n         *\n         * Now, Gamma/Yaw is not used (angle=0), so we assume cosG = 1 and sinG = 0, so\n         * we get:\n         * |     cosB    |   0    |   - sinB    |\n         * | sinA * sinB |  cosA  | sinA * cosB |\n         * | cosA * sinB | - sinA | cosA * cosB |\n         *\n         * But in browsers, y is reversed, so we get sinA => -sinA. The general result\n         * is:\n         * |      cosB     |   0    |    - sinB     |     | x |     | px |\n         * | - sinA * sinB |  cosA  | - sinA * cosB |  x  | y |  =  | py |\n         * |  cosA * sinB  |  sinA  |  cosA * cosB  |     | z |     | pz |\n         *\n         * @private\n         * @function rotate3D\n         */\n        /* eslint-enable max-len */\n        /**\n         * @private\n         * @param {number} x\n         *        X coordinate\n         * @param {number} y\n         *        Y coordinate\n         * @param {number} z\n         *        Z coordinate\n         * @param {Highcharts.Rotation3dObject} angles\n         *        Rotation angles\n         * @return {Highcharts.Rotation3dObject}\n         *         Rotated position\n         */\n        function rotate3D(x, y, z, angles) {\n            return {\n                x: angles.cosB * x - angles.sinB * z,\n                y: -angles.sinA * angles.sinB * x + angles.cosA * y -\n                    angles.cosB * angles.sinA * z,\n                z: angles.cosA * angles.sinB * x + angles.sinA * y +\n                    angles.cosA * angles.cosB * z\n            };\n        }\n        /**\n         * Perspective3D function is available in global Highcharts scope because is\n         * needed also outside of perspective() function (#8042).\n         * @private\n         * @function Highcharts.perspective3D\n         *\n         * @param {Highcharts.Position3dObject} coordinate\n         * 3D position\n         *\n         * @param {Highcharts.Position3dObject} origin\n         * 3D root position\n         *\n         * @param {number} distance\n         * Perspective distance\n         *\n         * @return {Highcharts.PositionObject}\n         * Perspective 3D Position\n         *\n         * @requires highcharts-3d\n         */\n        H.perspective3D = function (coordinate, origin, distance) {\n            var projection = ((distance > 0) && (distance < Number.POSITIVE_INFINITY)) ?\n                    distance / (coordinate.z + origin.z + distance) :\n                    1;\n            return {\n                x: coordinate.x * projection,\n                y: coordinate.y * projection\n            };\n        };\n        /**\n         * Transforms a given array of points according to the angles in chart.options.\n         *\n         * @private\n         * @function Highcharts.perspective\n         *\n         * @param {Array<Highcharts.Position3dObject>} points\n         * The array of points\n         *\n         * @param {Highcharts.Chart} chart\n         * The chart\n         *\n         * @param {boolean} [insidePlotArea]\n         * Wether to verifiy the points are inside the plotArea\n         *\n         * @return {Array<Highcharts.Position3dObject>}\n         * An array of transformed points\n         *\n         * @requires highcharts-3d\n         */\n        H.perspective = function (points, chart, insidePlotArea) {\n            var options3d = chart.options.chart.options3d,\n                inverted = insidePlotArea ? chart.inverted : false,\n                origin = {\n                    x: chart.plotWidth / 2,\n                    y: chart.plotHeight / 2,\n                    z: options3d.depth / 2,\n                    vd: pick(options3d.depth, 1) * pick(options3d.viewDistance, 0)\n                },\n                scale = chart.scale3d || 1,\n                beta = deg2rad * options3d.beta * (inverted ? -1 : 1),\n                alpha = deg2rad * options3d.alpha * (inverted ? -1 : 1),\n                angles = {\n                    cosA: Math.cos(alpha),\n                    cosB: Math.cos(-beta),\n                    sinA: Math.sin(alpha),\n                    sinB: Math.sin(-beta)\n                };\n            if (!insidePlotArea) {\n                origin.x += chart.plotLeft;\n                origin.y += chart.plotTop;\n            }\n            // Transform each point\n            return points.map(function (point) {\n                var rotated = rotate3D((inverted ? point.y : point.x) - origin.x, (inverted ? point.x : point.y) - origin.y, (point.z || 0) - origin.z,\n                    angles), \n                    // Apply perspective\n                    coordinate = H.perspective3D(rotated,\n                    origin,\n                    origin.vd);\n                // Apply translation\n                coordinate.x = coordinate.x * scale + origin.x;\n                coordinate.y = coordinate.y * scale + origin.y;\n                coordinate.z = rotated.z * scale + origin.z;\n                return {\n                    x: (inverted ? coordinate.y : coordinate.x),\n                    y: (inverted ? coordinate.x : coordinate.y),\n                    z: coordinate.z\n                };\n            });\n        };\n        /**\n         * Calculate a distance from camera to points - made for calculating zIndex of\n         * scatter points.\n         *\n         * @private\n         * @function Highcharts.pointCameraDistance\n         *\n         * @param {Highcharts.Dictionary<number>} coordinates\n         * Coordinates of the specific point\n         *\n         * @param {Highcharts.Chart} chart\n         * Related chart\n         *\n         * @return {number}\n         * Distance from camera to point\n         *\n         * @requires highcharts-3d\n         */\n        H.pointCameraDistance = function (coordinates, chart) {\n            var options3d = chart.options.chart.options3d,\n                cameraPosition = {\n                    x: chart.plotWidth / 2,\n                    y: chart.plotHeight / 2,\n                    z: pick(options3d.depth, 1) * pick(options3d.viewDistance, 0) +\n                        options3d.depth\n                },\n                distance = Math.sqrt(Math.pow(cameraPosition.x - coordinates.plotX, 2) +\n                    Math.pow(cameraPosition.y - coordinates.plotY, 2) +\n                    Math.pow(cameraPosition.z - coordinates.plotZ, 2));\n            return distance;\n        };\n        /**\n         * Calculate area of a 2D polygon using Shoelace algorithm\n         * http://en.wikipedia.org/wiki/Shoelace_formula\n         *\n         * @private\n         * @function Highcharts.shapeArea\n         *\n         * @param {Array<Highcharts.PositionObject>} vertexes\n         * 2D Polygon\n         *\n         * @return {number}\n         * Calculated area\n         *\n         * @requires highcharts-3d\n         */\n        H.shapeArea = function (vertexes) {\n            var area = 0,\n                i,\n                j;\n            for (i = 0; i < vertexes.length; i++) {\n                j = (i + 1) % vertexes.length;\n                area += vertexes[i].x * vertexes[j].y - vertexes[j].x * vertexes[i].y;\n            }\n            return area / 2;\n        };\n        /**\n         * Calculate area of a 3D polygon after perspective projection\n         *\n         * @private\n         * @function Highcharts.shapeArea3d\n         *\n         * @param {Array<Highcharts.Position3dObject>} vertexes\n         * 3D Polygon\n         *\n         * @param {Highcharts.Chart} chart\n         * Related chart\n         *\n         * @param {boolean} [insidePlotArea]\n         * Wether to verifiy the points are inside the plotArea\n         *\n         * @return {number}\n         * Calculated area\n         *\n         * @requires highcharts-3d\n         */\n        H.shapeArea3d = function (vertexes, chart, insidePlotArea) {\n            return H.shapeArea(H.perspective(vertexes, chart, insidePlotArea));\n        };\n\n    });\n    _registerModule(_modules, 'parts-3d/SVGRenderer.js', [_modules['parts/Globals.js'], _modules['parts/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  (c) 2010-2019 Torstein Honsi\n         *\n         *  Extensions to the SVGRenderer class to enable 3D shapes\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var animObject = U.animObject,\n            defined = U.defined,\n            extend = U.extend,\n            objectEach = U.objectEach,\n            pick = U.pick;\n        var cos = Math.cos,\n            PI = Math.PI,\n            sin = Math.sin;\n        var charts = H.charts,\n            color = H.color,\n            deg2rad = H.deg2rad,\n            merge = H.merge,\n            perspective = H.perspective,\n            SVGElement = H.SVGElement,\n            SVGRenderer = H.SVGRenderer, \n            // internal:\n            dFactor,\n            element3dMethods,\n            cuboidMethods;\n        /*\n            EXTENSION TO THE SVG-RENDERER TO ENABLE 3D SHAPES\n        */\n        // HELPER METHODS\n        dFactor = (4 * (Math.sqrt(2) - 1) / 3) / (PI / 2);\n        /* eslint-disable no-invalid-this, valid-jsdoc */\n        /**\n         * Method to construct a curved path. Can 'wrap' around more then 180 degrees.\n         * @private\n         */\n        function curveTo(cx, cy, rx, ry, start, end, dx, dy) {\n            var result = [],\n                arcAngle = end - start;\n            if ((end > start) && (end - start > Math.PI / 2 + 0.0001)) {\n                result = result.concat(curveTo(cx, cy, rx, ry, start, start + (Math.PI / 2), dx, dy));\n                result = result.concat(curveTo(cx, cy, rx, ry, start + (Math.PI / 2), end, dx, dy));\n                return result;\n            }\n            if ((end < start) && (start - end > Math.PI / 2 + 0.0001)) {\n                result = result.concat(curveTo(cx, cy, rx, ry, start, start - (Math.PI / 2), dx, dy));\n                result = result.concat(curveTo(cx, cy, rx, ry, start - (Math.PI / 2), end, dx, dy));\n                return result;\n            }\n            return [\n                'C',\n                cx + (rx * Math.cos(start)) -\n                    ((rx * dFactor * arcAngle) * Math.sin(start)) + dx,\n                cy + (ry * Math.sin(start)) +\n                    ((ry * dFactor * arcAngle) * Math.cos(start)) + dy,\n                cx + (rx * Math.cos(end)) +\n                    ((rx * dFactor * arcAngle) * Math.sin(end)) + dx,\n                cy + (ry * Math.sin(end)) -\n                    ((ry * dFactor * arcAngle) * Math.cos(end)) + dy,\n                cx + (rx * Math.cos(end)) + dx,\n                cy + (ry * Math.sin(end)) + dy\n            ];\n        }\n        SVGRenderer.prototype.toLinePath = function (points, closed) {\n            var result = [];\n            // Put \"L x y\" for each point\n            points.forEach(function (point) {\n                result.push('L', point.x, point.y);\n            });\n            if (points.length) {\n                // Set the first element to M\n                result[0] = 'M';\n                // If it is a closed line, add Z\n                if (closed) {\n                    result.push('Z');\n                }\n            }\n            return result;\n        };\n        SVGRenderer.prototype.toLineSegments = function (points) {\n            var result = [],\n                m = true;\n            points.forEach(function (point) {\n                result.push(m ? 'M' : 'L', point.x, point.y);\n                m = !m;\n            });\n            return result;\n        };\n        // A 3-D Face is defined by it's 3D vertexes, and is only visible if it's\n        // vertexes are counter-clockwise (Back-face culling). It is used as a\n        // polyhedron Element\n        SVGRenderer.prototype.face3d = function (args) {\n            var renderer = this,\n                ret = this.createElement('path');\n            ret.vertexes = [];\n            ret.insidePlotArea = false;\n            ret.enabled = true;\n            ret.attr = function (hash) {\n                if (typeof hash === 'object' &&\n                    (defined(hash.enabled) ||\n                        defined(hash.vertexes) ||\n                        defined(hash.insidePlotArea))) {\n                    this.enabled = pick(hash.enabled, this.enabled);\n                    this.vertexes = pick(hash.vertexes, this.vertexes);\n                    this.insidePlotArea = pick(hash.insidePlotArea, this.insidePlotArea);\n                    delete hash.enabled;\n                    delete hash.vertexes;\n                    delete hash.insidePlotArea;\n                    var chart = charts[renderer.chartIndex],\n                        vertexes2d = perspective(this.vertexes,\n                        chart,\n                        this.insidePlotArea),\n                        path = renderer.toLinePath(vertexes2d,\n                        true),\n                        area = H.shapeArea(vertexes2d),\n                        visibility = (this.enabled && area > 0) ? 'visible' : 'hidden';\n                    hash.d = path;\n                    hash.visibility = visibility;\n                }\n                return SVGElement.prototype.attr.apply(this, arguments);\n            };\n            ret.animate = function (params) {\n                if (typeof params === 'object' &&\n                    (defined(params.enabled) ||\n                        defined(params.vertexes) ||\n                        defined(params.insidePlotArea))) {\n                    this.enabled = pick(params.enabled, this.enabled);\n                    this.vertexes = pick(params.vertexes, this.vertexes);\n                    this.insidePlotArea = pick(params.insidePlotArea, this.insidePlotArea);\n                    delete params.enabled;\n                    delete params.vertexes;\n                    delete params.insidePlotArea;\n                    var chart = charts[renderer.chartIndex],\n                        vertexes2d = perspective(this.vertexes,\n                        chart,\n                        this.insidePlotArea),\n                        path = renderer.toLinePath(vertexes2d,\n                        true),\n                        area = H.shapeArea(vertexes2d),\n                        visibility = (this.enabled && area > 0) ? 'visible' : 'hidden';\n                    params.d = path;\n                    this.attr('visibility', visibility);\n                }\n                return SVGElement.prototype.animate.apply(this, arguments);\n            };\n            return ret.attr(args);\n        };\n        // A Polyhedron is a handy way of defining a group of 3-D faces. It's only\n        // attribute is `faces`, an array of attributes of each one of it's Face3D\n        // instances.\n        SVGRenderer.prototype.polyhedron = function (args) {\n            var renderer = this,\n                result = this.g(),\n                destroy = result.destroy;\n            if (!this.styledMode) {\n                result.attr({\n                    'stroke-linejoin': 'round'\n                });\n            }\n            result.faces = [];\n            // destroy all children\n            result.destroy = function () {\n                for (var i = 0; i < result.faces.length; i++) {\n                    result.faces[i].destroy();\n                }\n                return destroy.call(this);\n            };\n            result.attr = function (hash, val, complete, continueAnimation) {\n                if (typeof hash === 'object' && defined(hash.faces)) {\n                    while (result.faces.length > hash.faces.length) {\n                        result.faces.pop().destroy();\n                    }\n                    while (result.faces.length < hash.faces.length) {\n                        result.faces.push(renderer.face3d().add(result));\n                    }\n                    for (var i = 0; i < hash.faces.length; i++) {\n                        if (renderer.styledMode) {\n                            delete hash.faces[i].fill;\n                        }\n                        result.faces[i].attr(hash.faces[i], null, complete, continueAnimation);\n                    }\n                    delete hash.faces;\n                }\n                return SVGElement.prototype.attr.apply(this, arguments);\n            };\n            result.animate = function (params, duration, complete) {\n                if (params && params.faces) {\n                    while (result.faces.length > params.faces.length) {\n                        result.faces.pop().destroy();\n                    }\n                    while (result.faces.length < params.faces.length) {\n                        result.faces.push(renderer.face3d().add(result));\n                    }\n                    for (var i = 0; i < params.faces.length; i++) {\n                        result.faces[i].animate(params.faces[i], duration, complete);\n                    }\n                    delete params.faces;\n                }\n                return SVGElement.prototype.animate.apply(this, arguments);\n            };\n            return result.attr(args);\n        };\n        // Base, abstract prototype member for 3D elements\n        element3dMethods = {\n            /**\n             * The init is used by base - renderer.Element\n             * @private\n             */\n            initArgs: function (args) {\n                var elem3d = this,\n                    renderer = elem3d.renderer,\n                    paths = renderer[elem3d.pathType + 'Path'](args),\n                    zIndexes = paths.zIndexes;\n                // build parts\n                elem3d.parts.forEach(function (part) {\n                    elem3d[part] = renderer.path(paths[part]).attr({\n                        'class': 'highcharts-3d-' + part,\n                        zIndex: zIndexes[part] || 0\n                    }).add(elem3d);\n                });\n                elem3d.attr({\n                    'stroke-linejoin': 'round',\n                    zIndex: zIndexes.group\n                });\n                // store original destroy\n                elem3d.originalDestroy = elem3d.destroy;\n                elem3d.destroy = elem3d.destroyParts;\n            },\n            /**\n             * Single property setter that applies options to each part\n             * @private\n             */\n            singleSetterForParts: function (prop, val, values, verb, duration, complete) {\n                var elem3d = this,\n                    newAttr = {},\n                    optionsToApply = [null,\n                    null, (verb || 'attr'),\n                    duration,\n                    complete],\n                    hasZIndexes = values && values.zIndexes;\n                if (!values) {\n                    newAttr[prop] = val;\n                    optionsToApply[0] = newAttr;\n                }\n                else {\n                    objectEach(values, function (partVal, part) {\n                        newAttr[part] = {};\n                        newAttr[part][prop] = partVal;\n                        // include zIndexes if provided\n                        if (hasZIndexes) {\n                            newAttr[part].zIndex = values.zIndexes[part] || 0;\n                        }\n                    });\n                    optionsToApply[1] = newAttr;\n                }\n                return elem3d.processParts.apply(elem3d, optionsToApply);\n            },\n            /**\n             * Calls function for each part. Used for attr, animate and destroy.\n             * @private\n             */\n            processParts: function (props, partsProps, verb, duration, complete) {\n                var elem3d = this;\n                elem3d.parts.forEach(function (part) {\n                    // if different props for different parts\n                    if (partsProps) {\n                        props = pick(partsProps[part], false);\n                    }\n                    // only if something to set, but allow undefined\n                    if (props !== false) {\n                        elem3d[part][verb](props, duration, complete);\n                    }\n                });\n                return elem3d;\n            },\n            /**\n             * Destroy all parts\n             * @private\n             */\n            destroyParts: function () {\n                this.processParts(null, null, 'destroy');\n                return this.originalDestroy();\n            }\n        };\n        // CUBOID\n        cuboidMethods = H.merge(element3dMethods, {\n            parts: ['front', 'top', 'side'],\n            pathType: 'cuboid',\n            attr: function (args, val, complete, continueAnimation) {\n                // Resolve setting attributes by string name\n                if (typeof args === 'string' && typeof val !== 'undefined') {\n                    var key = args;\n                    args = {};\n                    args[key] = val;\n                }\n                if (args.shapeArgs || defined(args.x)) {\n                    return this.singleSetterForParts('d', null, this.renderer[this.pathType + 'Path'](args.shapeArgs || args));\n                }\n                return SVGElement.prototype.attr.call(this, args, void 0, complete, continueAnimation);\n            },\n            animate: function (args, duration, complete) {\n                if (defined(args.x) && defined(args.y)) {\n                    var paths = this.renderer[this.pathType + 'Path'](args);\n                    this.singleSetterForParts('d', null, paths, 'animate', duration, complete);\n                    this.attr({\n                        zIndex: paths.zIndexes.group\n                    });\n                }\n                else {\n                    SVGElement.prototype.animate.call(this, args, duration, complete);\n                }\n                return this;\n            },\n            fillSetter: function (fill) {\n                this.singleSetterForParts('fill', null, {\n                    front: fill,\n                    top: color(fill).brighten(0.1).get(),\n                    side: color(fill).brighten(-0.1).get()\n                });\n                // fill for animation getter (#6776)\n                this.color = this.fill = fill;\n                return this;\n            }\n        });\n        // set them up\n        SVGRenderer.prototype.elements3d = {\n            base: element3dMethods,\n            cuboid: cuboidMethods\n        };\n        /**\n         * return result, generalization\n         * @private\n         * @requires highcharts-3d\n         */\n        SVGRenderer.prototype.element3d = function (type, shapeArgs) {\n            // base\n            var ret = this.g();\n            // extend\n            extend(ret, this.elements3d[type]);\n            // init\n            ret.initArgs(shapeArgs);\n            // return\n            return ret;\n        };\n        // generelized, so now use simply\n        SVGRenderer.prototype.cuboid = function (shapeArgs) {\n            return this.element3d('cuboid', shapeArgs);\n        };\n        // Generates a cuboid path and zIndexes\n        H.SVGRenderer.prototype.cuboidPath = function (shapeArgs) {\n            var x = shapeArgs.x,\n                y = shapeArgs.y,\n                z = shapeArgs.z,\n                h = shapeArgs.height,\n                w = shapeArgs.width,\n                d = shapeArgs.depth,\n                chart = charts[this.chartIndex],\n                front,\n                back,\n                top,\n                bottom,\n                left,\n                right,\n                shape,\n                path1,\n                path2,\n                path3,\n                isFront,\n                isTop,\n                isRight,\n                options3d = chart.options.chart.options3d,\n                alpha = options3d.alpha, \n                // Priority for x axis is the biggest,\n                // because of x direction has biggest influence on zIndex\n                incrementX = 10000, \n                // y axis has the smallest priority in case of our charts\n                // (needs to be set because of stacking)\n                incrementY = 10,\n                incrementZ = 100,\n                zIndex = 0, \n                // The 8 corners of the cube\n                pArr = [{\n                        x: x,\n                        y: y,\n                        z: z\n                    }, {\n                        x: x + w,\n                        y: y,\n                        z: z\n                    }, {\n                        x: x + w,\n                        y: y + h,\n                        z: z\n                    }, {\n                        x: x,\n                        y: y + h,\n                        z: z\n                    }, {\n                        x: x,\n                        y: y + h,\n                        z: z + d\n                    }, {\n                        x: x + w,\n                        y: y + h,\n                        z: z + d\n                    }, {\n                        x: x + w,\n                        y: y,\n                        z: z + d\n                    }, {\n                        x: x,\n                        y: y,\n                        z: z + d\n                    }],\n                pickShape;\n            // apply perspective\n            pArr = perspective(pArr, chart, shapeArgs.insidePlotArea);\n            /**\n             * helper method to decide which side is visible\n             * @private\n             */\n            function mapPath(i) {\n                return pArr[i];\n            }\n            /**\n             * First value - path with specific side\n             * Second  value - added information about side for later calculations.\n             * Possible second values are 0 for path1, 1 for path2 and -1 for no path\n             * chosen.\n             * @private\n             */\n            pickShape = function (path1, path2) {\n                var ret = [[], -1];\n                path1 = path1.map(mapPath);\n                path2 = path2.map(mapPath);\n                if (H.shapeArea(path1) < 0) {\n                    ret = [path1, 0];\n                }\n                else if (H.shapeArea(path2) < 0) {\n                    ret = [path2, 1];\n                }\n                return ret;\n            };\n            // front or back\n            front = [3, 2, 1, 0];\n            back = [7, 6, 5, 4];\n            shape = pickShape(front, back);\n            path1 = shape[0];\n            isFront = shape[1];\n            // top or bottom\n            top = [1, 6, 7, 0];\n            bottom = [4, 5, 2, 3];\n            shape = pickShape(top, bottom);\n            path2 = shape[0];\n            isTop = shape[1];\n            // side\n            right = [1, 2, 5, 6];\n            left = [0, 7, 4, 3];\n            shape = pickShape(right, left);\n            path3 = shape[0];\n            isRight = shape[1];\n            /* New block used for calculating zIndex. It is basing on X, Y and Z\n               position of specific columns. All zIndexes (for X, Y and Z values) are\n               added to the final zIndex, where every value has different priority. The\n               biggest priority is in X and Z directions, the lowest index is for\n               stacked columns (Y direction and the same X and Z positions). Big\n               differences between priorities is made because we need to ensure that\n               even for big changes in Y and Z parameters all columns will be drawn\n               correctly. */\n            if (isRight === 1) {\n                zIndex += incrementX * (1000 - x);\n            }\n            else if (!isRight) {\n                zIndex += incrementX * x;\n            }\n            zIndex += incrementY * (!isTop ||\n                // Numbers checked empirically\n                (alpha >= 0 && alpha <= 180 || alpha < 360 && alpha > 357.5) ?\n                chart.plotHeight - y : 10 + y);\n            if (isFront === 1) {\n                zIndex += incrementZ * (z);\n            }\n            else if (!isFront) {\n                zIndex += incrementZ * (1000 - z);\n            }\n            return {\n                front: this.toLinePath(path1, true),\n                top: this.toLinePath(path2, true),\n                side: this.toLinePath(path3, true),\n                zIndexes: {\n                    group: Math.round(zIndex)\n                },\n                // additional info about zIndexes\n                isFront: isFront,\n                isTop: isTop\n            }; // #4774\n        };\n        // SECTORS //\n        H.SVGRenderer.prototype.arc3d = function (attribs) {\n            var wrapper = this.g(), renderer = wrapper.renderer, customAttribs = ['x', 'y', 'r', 'innerR', 'start', 'end'];\n            /**\n             * Get custom attributes. Don't mutate the original object and return an\n             * object with only custom attr.\n             * @private\n             */\n            function suckOutCustom(params) {\n                var hasCA = false,\n                    ca = {},\n                    key;\n                params = merge(params); // Don't mutate the original object\n                for (key in params) {\n                    if (customAttribs.indexOf(key) !== -1) {\n                        ca[key] = params[key];\n                        delete params[key];\n                        hasCA = true;\n                    }\n                }\n                return hasCA ? ca : false;\n            }\n            attribs = merge(attribs);\n            attribs.alpha = (attribs.alpha || 0) * deg2rad;\n            attribs.beta = (attribs.beta || 0) * deg2rad;\n            // Create the different sub sections of the shape\n            wrapper.top = renderer.path();\n            wrapper.side1 = renderer.path();\n            wrapper.side2 = renderer.path();\n            wrapper.inn = renderer.path();\n            wrapper.out = renderer.path();\n            // Add all faces\n            wrapper.onAdd = function () {\n                var parent = wrapper.parentGroup,\n                    className = wrapper.attr('class');\n                wrapper.top.add(wrapper);\n                // These faces are added outside the wrapper group because the z index\n                // relates to neighbour elements as well\n                ['out', 'inn', 'side1', 'side2'].forEach(function (face) {\n                    wrapper[face]\n                        .attr({\n                        'class': className + ' highcharts-3d-side'\n                    })\n                        .add(parent);\n                });\n            };\n            // Cascade to faces\n            ['addClass', 'removeClass'].forEach(function (fn) {\n                wrapper[fn] = function () {\n                    var args = arguments;\n                    ['top', 'out', 'inn', 'side1', 'side2'].forEach(function (face) {\n                        wrapper[face][fn].apply(wrapper[face], args);\n                    });\n                };\n            });\n            /**\n             * Compute the transformed paths and set them to the composite shapes\n             * @private\n             */\n            wrapper.setPaths = function (attribs) {\n                var paths = wrapper.renderer.arc3dPath(attribs),\n                    zIndex = paths.zTop * 100;\n                wrapper.attribs = attribs;\n                wrapper.top.attr({ d: paths.top, zIndex: paths.zTop });\n                wrapper.inn.attr({ d: paths.inn, zIndex: paths.zInn });\n                wrapper.out.attr({ d: paths.out, zIndex: paths.zOut });\n                wrapper.side1.attr({ d: paths.side1, zIndex: paths.zSide1 });\n                wrapper.side2.attr({ d: paths.side2, zIndex: paths.zSide2 });\n                // show all children\n                wrapper.zIndex = zIndex;\n                wrapper.attr({ zIndex: zIndex });\n                // Set the radial gradient center the first time\n                if (attribs.center) {\n                    wrapper.top.setRadialReference(attribs.center);\n                    delete attribs.center;\n                }\n            };\n            wrapper.setPaths(attribs);\n            /**\n             * Apply the fill to the top and a darker shade to the sides\n             * @private\n             */\n            wrapper.fillSetter = function (value) {\n                var darker = color(value).brighten(-0.1).get();\n                this.fill = value;\n                this.side1.attr({ fill: darker });\n                this.side2.attr({ fill: darker });\n                this.inn.attr({ fill: darker });\n                this.out.attr({ fill: darker });\n                this.top.attr({ fill: value });\n                return this;\n            };\n            // Apply the same value to all. These properties cascade down to the\n            // children when set to the composite arc3d.\n            ['opacity', 'translateX', 'translateY', 'visibility'].forEach(function (setter) {\n                wrapper[setter + 'Setter'] = function (value, key) {\n                    wrapper[key] = value;\n                    ['out', 'inn', 'side1', 'side2', 'top'].forEach(function (el) {\n                        wrapper[el].attr(key, value);\n                    });\n                };\n            });\n            // Override attr to remove shape attributes and use those to set child paths\n            wrapper.attr = function (params) {\n                var ca;\n                if (typeof params === 'object') {\n                    ca = suckOutCustom(params);\n                    if (ca) {\n                        extend(wrapper.attribs, ca);\n                        wrapper.setPaths(wrapper.attribs);\n                    }\n                }\n                return SVGElement.prototype.attr.apply(wrapper, arguments);\n            };\n            // Override the animate function by sucking out custom parameters related to\n            // the shapes directly, and update the shapes from the animation step.\n            wrapper.animate = function (params, animation, complete) {\n                var ca,\n                    from = this.attribs,\n                    to,\n                    anim,\n                    randomProp = 'data-' + Math.random().toString(26).substring(2, 9);\n                // Attribute-line properties connected to 3D. These shouldn't have been\n                // in the attribs collection in the first place.\n                delete params.center;\n                delete params.z;\n                delete params.depth;\n                delete params.alpha;\n                delete params.beta;\n                anim = animObject(pick(animation, this.renderer.globalAnimation));\n                if (anim.duration) {\n                    ca = suckOutCustom(params);\n                    // Params need to have a property in order for the step to run\n                    // (#5765, #7097, #7437)\n                    wrapper[randomProp] = 0;\n                    params[randomProp] = 1;\n                    wrapper[randomProp + 'Setter'] = H.noop;\n                    if (ca) {\n                        to = ca;\n                        anim.step = function (a, fx) {\n                            /**\n                             * @private\n                             */\n                            function interpolate(key) {\n                                return from[key] + (pick(to[key], from[key]) -\n                                    from[key]) * fx.pos;\n                            }\n                            if (fx.prop === randomProp) {\n                                fx.elem.setPaths(merge(from, {\n                                    x: interpolate('x'),\n                                    y: interpolate('y'),\n                                    r: interpolate('r'),\n                                    innerR: interpolate('innerR'),\n                                    start: interpolate('start'),\n                                    end: interpolate('end')\n                                }));\n                            }\n                        };\n                    }\n                    animation = anim; // Only when duration (#5572)\n                }\n                return SVGElement.prototype.animate.call(this, params, animation, complete);\n            };\n            // destroy all children\n            wrapper.destroy = function () {\n                this.top.destroy();\n                this.out.destroy();\n                this.inn.destroy();\n                this.side1.destroy();\n                this.side2.destroy();\n                return SVGElement.prototype.destroy.call(this);\n            };\n            // hide all children\n            wrapper.hide = function () {\n                this.top.hide();\n                this.out.hide();\n                this.inn.hide();\n                this.side1.hide();\n                this.side2.hide();\n            };\n            wrapper.show = function (inherit) {\n                this.top.show(inherit);\n                this.out.show(inherit);\n                this.inn.show(inherit);\n                this.side1.show(inherit);\n                this.side2.show(inherit);\n            };\n            return wrapper;\n        };\n        // Generate the paths required to draw a 3D arc\n        SVGRenderer.prototype.arc3dPath = function (shapeArgs) {\n            var cx = shapeArgs.x, // x coordinate of the center\n                cy = shapeArgs.y, // y coordinate of the center\n                start = shapeArgs.start, // start angle\n                end = shapeArgs.end - 0.00001, // end angle\n                r = shapeArgs.r, // radius\n                ir = shapeArgs.innerR || 0, // inner radius\n                d = shapeArgs.depth || 0, // depth\n                alpha = shapeArgs.alpha, // alpha rotation of the chart\n                beta = shapeArgs.beta; // beta rotation of the chart\n                // Derived Variables\n                var cs = Math.cos(start), // cosinus of the start angle\n                ss = Math.sin(start), // sinus of the start angle\n                ce = Math.cos(end), // cosinus of the end angle\n                se = Math.sin(end), // sinus of the end angle\n                rx = r * Math.cos(beta), // x-radius\n                ry = r * Math.cos(alpha), // y-radius\n                irx = ir * Math.cos(beta), // x-radius (inner)\n                iry = ir * Math.cos(alpha), // y-radius (inner)\n                dx = d * Math.sin(beta), // distance between top and bottom in x\n                dy = d * Math.sin(alpha); // distance between top and bottom in y\n                // TOP\n                var top = ['M',\n                cx + (rx * cs),\n                cy + (ry * ss)];\n            top = top.concat(curveTo(cx, cy, rx, ry, start, end, 0, 0));\n            top = top.concat([\n                'L', cx + (irx * ce), cy + (iry * se)\n            ]);\n            top = top.concat(curveTo(cx, cy, irx, iry, end, start, 0, 0));\n            top = top.concat(['Z']);\n            // OUTSIDE\n            var b = (beta > 0 ? Math.PI / 2 : 0),\n                a = (alpha > 0 ? 0 : Math.PI / 2);\n            var start2 = start > -b ? start : (end > -b ? -b : start),\n                end2 = end < PI - a ? end : (start < PI - a ? PI - a : end),\n                midEnd = 2 * PI - a;\n            // When slice goes over bottom middle, need to add both, left and right\n            // outer side. Additionally, when we cross right hand edge, create sharp\n            // edge. Outer shape/wall:\n            //\n            //            -------\n            //          /    ^    \\\n            //    4)   /   /   \\   \\  1)\n            //        /   /     \\   \\\n            //       /   /       \\   \\\n            // (c)=> ====         ==== <=(d)\n            //       \\   \\       /   /\n            //        \\   \\<=(a)/   /\n            //         \\   \\   /   / <=(b)\n            //    3)    \\    v    /  2)\n            //            -------\n            //\n            // (a) - inner side\n            // (b) - outer side\n            // (c) - left edge (sharp)\n            // (d) - right edge (sharp)\n            // 1..n - rendering order for startAngle = 0, when set to e.g 90, order\n            // changes clockwise (1->2, 2->3, n->1) and counterclockwise for negative\n            // startAngle\n            var out = ['M',\n                cx + (rx * cos(start2)),\n                cy + (ry * sin(start2))];\n            out = out.concat(curveTo(cx, cy, rx, ry, start2, end2, 0, 0));\n            // When shape is wide, it can cross both, (c) and (d) edges, when using\n            // startAngle\n            if (end > midEnd && start < midEnd) {\n                // Go to outer side\n                out = out.concat([\n                    'L', cx + (rx * cos(end2)) + dx, cy + (ry * sin(end2)) + dy\n                ]);\n                // Curve to the right edge of the slice (d)\n                out = out.concat(curveTo(cx, cy, rx, ry, end2, midEnd, dx, dy));\n                // Go to the inner side\n                out = out.concat([\n                    'L', cx + (rx * cos(midEnd)), cy + (ry * sin(midEnd))\n                ]);\n                // Curve to the true end of the slice\n                out = out.concat(curveTo(cx, cy, rx, ry, midEnd, end, 0, 0));\n                // Go to the outer side\n                out = out.concat([\n                    'L', cx + (rx * cos(end)) + dx, cy + (ry * sin(end)) + dy\n                ]);\n                // Go back to middle (d)\n                out = out.concat(curveTo(cx, cy, rx, ry, end, midEnd, dx, dy));\n                out = out.concat([\n                    'L', cx + (rx * cos(midEnd)), cy + (ry * sin(midEnd))\n                ]);\n                // Go back to the left edge\n                out = out.concat(curveTo(cx, cy, rx, ry, midEnd, end2, 0, 0));\n                // But shape can cross also only (c) edge:\n            }\n            else if (end > PI - a && start < PI - a) {\n                // Go to outer side\n                out = out.concat([\n                    'L',\n                    cx + (rx * Math.cos(end2)) + dx,\n                    cy + (ry * Math.sin(end2)) + dy\n                ]);\n                // Curve to the true end of the slice\n                out = out.concat(curveTo(cx, cy, rx, ry, end2, end, dx, dy));\n                // Go to the inner side\n                out = out.concat([\n                    'L', cx + (rx * Math.cos(end)), cy + (ry * Math.sin(end))\n                ]);\n                // Go back to the artifical end2\n                out = out.concat(curveTo(cx, cy, rx, ry, end, end2, 0, 0));\n            }\n            out = out.concat([\n                'L', cx + (rx * Math.cos(end2)) + dx, cy + (ry * Math.sin(end2)) + dy\n            ]);\n            out = out.concat(curveTo(cx, cy, rx, ry, end2, start2, dx, dy));\n            out = out.concat(['Z']);\n            // INSIDE\n            var inn = ['M',\n                cx + (irx * cs),\n                cy + (iry * ss)];\n            inn = inn.concat(curveTo(cx, cy, irx, iry, start, end, 0, 0));\n            inn = inn.concat([\n                'L', cx + (irx * Math.cos(end)) + dx, cy + (iry * Math.sin(end)) + dy\n            ]);\n            inn = inn.concat(curveTo(cx, cy, irx, iry, end, start, dx, dy));\n            inn = inn.concat(['Z']);\n            // SIDES\n            var side1 = [\n                    'M',\n                cx + (rx * cs),\n                cy + (ry * ss),\n                    'L',\n                cx + (rx * cs) + dx,\n                cy + (ry * ss) + dy,\n                    'L',\n                cx + (irx * cs) + dx,\n                cy + (iry * ss) + dy,\n                    'L',\n                cx + (irx * cs),\n                cy + (iry * ss),\n                    'Z'\n                ];\n            var side2 = [\n                    'M',\n                cx + (rx * ce),\n                cy + (ry * se),\n                    'L',\n                cx + (rx * ce) + dx,\n                cy + (ry * se) + dy,\n                    'L',\n                cx + (irx * ce) + dx,\n                cy + (iry * se) + dy,\n                    'L',\n                cx + (irx * ce),\n                cy + (iry * se),\n                    'Z'\n                ];\n            // correction for changed position of vanishing point caused by alpha and\n            // beta rotations\n            var angleCorr = Math.atan2(dy, -dx),\n                angleEnd = Math.abs(end + angleCorr),\n                angleStart = Math.abs(start + angleCorr),\n                angleMid = Math.abs((start + end) / 2 + angleCorr);\n            /**\n             * set to 0-PI range\n             * @private\n             */\n            function toZeroPIRange(angle) {\n                angle = angle % (2 * Math.PI);\n                if (angle > Math.PI) {\n                    angle = 2 * Math.PI - angle;\n                }\n                return angle;\n            }\n            angleEnd = toZeroPIRange(angleEnd);\n            angleStart = toZeroPIRange(angleStart);\n            angleMid = toZeroPIRange(angleMid);\n            // *1e5 is to compensate pInt in zIndexSetter\n            var incPrecision = 1e5,\n                a1 = angleMid * incPrecision,\n                a2 = angleStart * incPrecision,\n                a3 = angleEnd * incPrecision;\n            return {\n                top: top,\n                // max angle is PI, so this is always higher\n                zTop: Math.PI * incPrecision + 1,\n                out: out,\n                zOut: Math.max(a1, a2, a3),\n                inn: inn,\n                zInn: Math.max(a1, a2, a3),\n                side1: side1,\n                zSide1: a3 * 0.99,\n                side2: side2,\n                zSide2: a2 * 0.99\n            };\n        };\n\n    });\n    _registerModule(_modules, 'parts-3d/Chart.js', [_modules['parts/Globals.js'], _modules['parts/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  (c) 2010-2019 Torstein Honsi\n         *\n         *  Extension for 3D charts\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var isArray = U.isArray,\n            pick = U.pick,\n            wrap = U.wrap;\n        var addEvent = H.addEvent,\n            Chart = H.Chart,\n            merge = H.merge,\n            perspective = H.perspective;\n        /**\n         * Shorthand to check the is3d flag.\n         * @private\n         * @return {boolean}\n         *         Whether it is a 3D chart.\n         */\n        Chart.prototype.is3d = function () {\n            return (this.options.chart.options3d &&\n                this.options.chart.options3d.enabled); // #4280\n        };\n        Chart.prototype.propsRequireDirtyBox.push('chart.options3d');\n        Chart.prototype.propsRequireUpdateSeries.push('chart.options3d');\n        /* eslint-disable no-invalid-this */\n        // Legacy support for HC < 6 to make 'scatter' series in a 3D chart route to the\n        // real 'scatter3d' series type.\n        addEvent(Chart, 'afterInit', function () {\n            var options = this.options;\n            if (this.is3d()) {\n                (options.series || []).forEach(function (s) {\n                    var type = s.type ||\n                            options.chart.type ||\n                            options.chart.defaultSeriesType;\n                    if (type === 'scatter') {\n                        s.type = 'scatter3d';\n                    }\n                });\n            }\n        });\n        // And do it on dynamic add (#8407)\n        addEvent(Chart, 'addSeries', function (e) {\n            if (this.is3d()) {\n                if (e.options.type === 'scatter') {\n                    e.options.type = 'scatter3d';\n                }\n            }\n        });\n        /**\n         * Calculate scale of the 3D view. That is required to\n         * fit chart's 3D projection into the actual plotting area. Reported as #4933.\n         * @notice This function should ideally take the plot values instead of a chart\n         *         object, but since the chart object is needed for perspective it is\n         *         not practical. Possible to make both getScale and perspective more\n         *         logical and also immutable.\n         *\n         * @private\n         * @function getScale\n         *\n         * @param {Highcharts.Chart} chart\n         * Chart object\n         *\n         * @param {number} depth\n         * The depth of the chart\n         *\n         * @return {number}\n         * The scale to fit the 3D chart into the plotting area.\n         *\n         * @requires highcharts-3d\n         */\n        function getScale(chart, depth) {\n            var plotLeft = chart.plotLeft,\n                plotRight = chart.plotWidth + plotLeft,\n                plotTop = chart.plotTop,\n                plotBottom = chart.plotHeight + plotTop,\n                originX = plotLeft + chart.plotWidth / 2,\n                originY = plotTop + chart.plotHeight / 2,\n                bbox3d = {\n                    minX: Number.MAX_VALUE,\n                    maxX: -Number.MAX_VALUE,\n                    minY: Number.MAX_VALUE,\n                    maxY: -Number.MAX_VALUE\n                },\n                corners,\n                scale = 1;\n            // Top left corners:\n            corners = [{\n                    x: plotLeft,\n                    y: plotTop,\n                    z: 0\n                }, {\n                    x: plotLeft,\n                    y: plotTop,\n                    z: depth\n                }];\n            // Top right corners:\n            [0, 1].forEach(function (i) {\n                corners.push({\n                    x: plotRight,\n                    y: corners[i].y,\n                    z: corners[i].z\n                });\n            });\n            // All bottom corners:\n            [0, 1, 2, 3].forEach(function (i) {\n                corners.push({\n                    x: corners[i].x,\n                    y: plotBottom,\n                    z: corners[i].z\n                });\n            });\n            // Calculate 3D corners:\n            corners = perspective(corners, chart, false);\n            // Get bounding box of 3D element:\n            corners.forEach(function (corner) {\n                bbox3d.minX = Math.min(bbox3d.minX, corner.x);\n                bbox3d.maxX = Math.max(bbox3d.maxX, corner.x);\n                bbox3d.minY = Math.min(bbox3d.minY, corner.y);\n                bbox3d.maxY = Math.max(bbox3d.maxY, corner.y);\n            });\n            // Left edge:\n            if (plotLeft > bbox3d.minX) {\n                scale = Math.min(scale, 1 - Math.abs((plotLeft + originX) / (bbox3d.minX + originX)) % 1);\n            }\n            // Right edge:\n            if (plotRight < bbox3d.maxX) {\n                scale = Math.min(scale, (plotRight - originX) / (bbox3d.maxX - originX));\n            }\n            // Top edge:\n            if (plotTop > bbox3d.minY) {\n                if (bbox3d.minY < 0) {\n                    scale = Math.min(scale, (plotTop + originY) / (-bbox3d.minY + plotTop + originY));\n                }\n                else {\n                    scale = Math.min(scale, 1 - (plotTop + originY) / (bbox3d.minY + originY) % 1);\n                }\n            }\n            // Bottom edge:\n            if (plotBottom < bbox3d.maxY) {\n                scale = Math.min(scale, Math.abs((plotBottom - originY) / (bbox3d.maxY - originY)));\n            }\n            return scale;\n        }\n        wrap(H.Chart.prototype, 'isInsidePlot', function (proceed) {\n            return this.is3d() || proceed.apply(this, [].slice.call(arguments, 1));\n        });\n        var defaultOptions = H.getOptions();\n        /**\n         * @optionparent\n         */\n        var extendedOptions = {\n                chart: {\n                    /**\n                     * Options to render charts in 3 dimensions. This feature requires\n                     * `highcharts-3d.js`,\n            found in the download package or online at\n                     * [code.highcharts.com/highcharts-3d.js](http://code.highcharts.com/highcharts-3d.js).\n                     *\n                     * @since    4.0\n                     * @product  highcharts\n                     * @requires highcharts-3d\n                     */\n                    options3d: {\n                        /**\n                         * Wether to render the chart using the 3D functionality.\n                         *\n                         * @since   4.0\n                         * @product highcharts\n                         */\n                        enabled: false,\n                        /**\n                         * One of the two rotation angles for the chart.\n                         *\n                         * @since   4.0\n                         * @product highcharts\n                         */\n                        alpha: 0,\n                        /**\n                         * One of the two rotation angles for the chart.\n                         *\n                         * @since   4.0\n                         * @product highcharts\n                         */\n                        beta: 0,\n                        /**\n                         * The total depth of the chart.\n                         *\n                         * @since   4.0\n                         * @product highcharts\n                         */\n                        depth: 100,\n                        /**\n                         * Whether the 3d box should automatically adjust to the chart plot\n                         * area.\n                         *\n                         * @since   4.2.4\n                         * @product highcharts\n                         */\n                        fitToPlot: true,\n                        /**\n                         * Defines the distance the viewer is standing in front of the\n                         * chart,\n            this setting is important to calculate the perspective\n                         * effect in column and scatter charts. It is not used for 3D pie\n                         * charts.\n                         *\n                         * @since   4.0\n                         * @product highcharts\n                         */\n                        viewDistance: 25,\n                        /**\n                         * Set it to `\"auto\"` to automatically move the labels to the best\n                         * edge.\n                         *\n                         * @type    {\"auto\"|null}\n                         * @since   5.0.12\n                         * @product highcharts\n                         */\n                        axisLabelPosition: null,\n                        /**\n                         * Provides the option to draw a frame around the charts by defining\n                         * a bottom,\n            front and back panel.\n                         *\n                         * @since    4.0\n                         * @product  highcharts\n                         * @requires highcharts-3d\n                         */\n                        frame: {\n                            /**\n                             * Whether the frames are visible.\n                             */\n                            visible: 'default',\n                            /**\n                             * General pixel thickness for the frame faces.\n                             */\n                            size: 1,\n                            /**\n                             * The bottom of the frame around a 3D chart.\n                             *\n                             * @since    4.0\n                             * @product  highcharts\n                             * @requires highcharts-3d\n                             */\n                            /**\n                             * The color of the panel.\n                             *\n                             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                             * @default   transparent\n                             * @since     4.0\n                             * @product   highcharts\n                             * @apioption chart.options3d.frame.bottom.color\n                             */\n                            /**\n                             * The thickness of the panel.\n                             *\n                             * @type      {number}\n                             * @default   1\n                             * @since     4.0\n                             * @product   highcharts\n                             * @apioption chart.options3d.frame.bottom.size\n                             */\n                            /**\n                             * Whether to display the frame. Possible values are `true`,\n                             * `false`,\n            `\"auto\"` to display only the frames behind the data,\n                             * and `\"default\"` to display faces behind the data based on the\n                             * axis layout,\n            ignoring the point of view.\n                             *\n                             * @sample {highcharts} highcharts/3d/scatter-frame/\n                             *         Auto frames\n                             *\n                             * @type      {boolean|\"default\"|\"auto\"}\n                             * @default   default\n                             * @since     5.0.12\n                             * @product   highcharts\n                             * @apioption chart.options3d.frame.bottom.visible\n                             */\n                            /**\n                             * The bottom of the frame around a 3D chart.\n                             */\n                            bottom: {},\n                            /**\n                             * The top of the frame around a 3D chart.\n                             *\n                             * @extends chart.options3d.frame.bottom\n                             */\n                            top: {},\n                            /**\n                             * The left side of the frame around a 3D chart.\n                             *\n                             * @extends chart.options3d.frame.bottom\n                             */\n                            left: {},\n                            /**\n                             * The right of the frame around a 3D chart.\n                             *\n                             * @extends chart.options3d.frame.bottom\n                             */\n                            right: {},\n                            /**\n                             * The back side of the frame around a 3D chart.\n                             *\n                             * @extends chart.options3d.frame.bottom\n                             */\n                            back: {},\n                            /**\n                             * The front of the frame around a 3D chart.\n                             *\n                             * @extends chart.options3d.frame.bottom\n                             */\n                            front: {}\n                        }\n                    }\n                }\n            };\n        merge(true, defaultOptions, extendedOptions);\n        // Add the required CSS classes for column sides (#6018)\n        addEvent(Chart, 'afterGetContainer', function () {\n            if (this.styledMode) {\n                this.renderer.definition({\n                    tagName: 'style',\n                    textContent: '.highcharts-3d-top{' +\n                        'filter: url(#highcharts-brighter)' +\n                        '}\\n' +\n                        '.highcharts-3d-side{' +\n                        'filter: url(#highcharts-darker)' +\n                        '}\\n'\n                });\n                // Add add definitions used by brighter and darker faces of the cuboids.\n                [{\n                        name: 'darker',\n                        slope: 0.6\n                    }, {\n                        name: 'brighter',\n                        slope: 1.4\n                    }].forEach(function (cfg) {\n                    this.renderer.definition({\n                        tagName: 'filter',\n                        id: 'highcharts-' + cfg.name,\n                        children: [{\n                                tagName: 'feComponentTransfer',\n                                children: [{\n                                        tagName: 'feFuncR',\n                                        type: 'linear',\n                                        slope: cfg.slope\n                                    }, {\n                                        tagName: 'feFuncG',\n                                        type: 'linear',\n                                        slope: cfg.slope\n                                    }, {\n                                        tagName: 'feFuncB',\n                                        type: 'linear',\n                                        slope: cfg.slope\n                                    }]\n                            }]\n                    });\n                }, this);\n            }\n        });\n        wrap(Chart.prototype, 'setClassName', function (proceed) {\n            proceed.apply(this, [].slice.call(arguments, 1));\n            if (this.is3d()) {\n                this.container.className += ' highcharts-3d-chart';\n            }\n        });\n        addEvent(H.Chart, 'afterSetChartSize', function () {\n            var chart = this,\n                options3d = chart.options.chart.options3d;\n            if (chart.is3d()) {\n                var inverted = chart.inverted, clipBox = chart.clipBox, margin = chart.margin, x = inverted ? 'y' : 'x', y = inverted ? 'x' : 'y', w = inverted ? 'height' : 'width', h = inverted ? 'width' : 'height';\n                clipBox[x] = -(margin[3] || 0);\n                clipBox[y] = -(margin[0] || 0);\n                clipBox[w] =\n                    chart.chartWidth + (margin[3] || 0) + (margin[1] || 0);\n                clipBox[h] =\n                    chart.chartHeight + (margin[0] || 0) + (margin[2] || 0);\n                // Set scale, used later in perspective method():\n                // getScale uses perspective, so scale3d has to be reset.\n                chart.scale3d = 1;\n                if (options3d.fitToPlot === true) {\n                    chart.scale3d = getScale(chart, options3d.depth);\n                }\n                // Recalculate the 3d frame with every call of setChartSize,\n                // instead of doing it after every redraw(). It avoids ticks\n                // and axis title outside of chart.\n                chart.frame3d = this.get3dFrame(); // #7942\n            }\n        });\n        addEvent(Chart, 'beforeRedraw', function () {\n            if (this.is3d()) {\n                // Set to force a redraw of all elements\n                this.isDirtyBox = true;\n            }\n        });\n        addEvent(Chart, 'beforeRender', function () {\n            if (this.is3d()) {\n                this.frame3d = this.get3dFrame();\n            }\n        });\n        // Draw the series in the reverse order (#3803, #3917)\n        wrap(Chart.prototype, 'renderSeries', function (proceed) {\n            var series,\n                i = this.series.length;\n            if (this.is3d()) {\n                while (i--) {\n                    series = this.series[i];\n                    series.translate();\n                    series.render();\n                }\n            }\n            else {\n                proceed.call(this);\n            }\n        });\n        addEvent(Chart, 'afterDrawChartBox', function () {\n            if (this.is3d()) {\n                var chart = this,\n                    renderer = chart.renderer,\n                    options3d = this.options.chart.options3d,\n                    frame = chart.get3dFrame(),\n                    xm = this.plotLeft,\n                    xp = this.plotLeft + this.plotWidth,\n                    ym = this.plotTop,\n                    yp = this.plotTop + this.plotHeight,\n                    zm = 0,\n                    zp = options3d.depth,\n                    xmm = xm - (frame.left.visible ? frame.left.size : 0),\n                    xpp = xp + (frame.right.visible ? frame.right.size : 0),\n                    ymm = ym - (frame.top.visible ? frame.top.size : 0),\n                    ypp = yp + (frame.bottom.visible ? frame.bottom.size : 0),\n                    zmm = zm - (frame.front.visible ? frame.front.size : 0),\n                    zpp = zp + (frame.back.visible ? frame.back.size : 0),\n                    verb = chart.hasRendered ? 'animate' : 'attr';\n                this.frame3d = frame;\n                if (!this.frameShapes) {\n                    this.frameShapes = {\n                        bottom: renderer.polyhedron().add(),\n                        top: renderer.polyhedron().add(),\n                        left: renderer.polyhedron().add(),\n                        right: renderer.polyhedron().add(),\n                        back: renderer.polyhedron().add(),\n                        front: renderer.polyhedron().add()\n                    };\n                }\n                this.frameShapes.bottom[verb]({\n                    'class': 'highcharts-3d-frame highcharts-3d-frame-bottom',\n                    zIndex: frame.bottom.frontFacing ? -1000 : 1000,\n                    faces: [{\n                            fill: H.color(frame.bottom.color).brighten(0.1).get(),\n                            vertexes: [{\n                                    x: xmm,\n                                    y: ypp,\n                                    z: zmm\n                                }, {\n                                    x: xpp,\n                                    y: ypp,\n                                    z: zmm\n                                }, {\n                                    x: xpp,\n                                    y: ypp,\n                                    z: zpp\n                                }, {\n                                    x: xmm,\n                                    y: ypp,\n                                    z: zpp\n                                }],\n                            enabled: frame.bottom.visible\n                        },\n                        {\n                            fill: H.color(frame.bottom.color).brighten(0.1).get(),\n                            vertexes: [{\n                                    x: xm,\n                                    y: yp,\n                                    z: zp\n                                }, {\n                                    x: xp,\n                                    y: yp,\n                                    z: zp\n                                }, {\n                                    x: xp,\n                                    y: yp,\n                                    z: zm\n                                }, {\n                                    x: xm,\n                                    y: yp,\n                                    z: zm\n                                }],\n                            enabled: frame.bottom.visible\n                        },\n                        {\n                            fill: H.color(frame.bottom.color).brighten(-0.1).get(),\n                            vertexes: [{\n                                    x: xmm,\n                                    y: ypp,\n                                    z: zmm\n                                }, {\n                                    x: xmm,\n                                    y: ypp,\n                                    z: zpp\n                                }, {\n                                    x: xm,\n                                    y: yp,\n                                    z: zp\n                                }, {\n                                    x: xm,\n                                    y: yp,\n                                    z: zm\n                                }],\n                            enabled: frame.bottom.visible && !frame.left.visible\n                        },\n                        {\n                            fill: H.color(frame.bottom.color).brighten(-0.1).get(),\n                            vertexes: [{\n                                    x: xpp,\n                                    y: ypp,\n                                    z: zpp\n                                }, {\n                                    x: xpp,\n                                    y: ypp,\n                                    z: zmm\n                                }, {\n                                    x: xp,\n                                    y: yp,\n                                    z: zm\n                                }, {\n                                    x: xp,\n                                    y: yp,\n                                    z: zp\n                                }],\n                            enabled: frame.bottom.visible && !frame.right.visible\n                        },\n                        {\n                            fill: H.color(frame.bottom.color).get(),\n                            vertexes: [{\n                                    x: xpp,\n                                    y: ypp,\n                                    z: zmm\n                                }, {\n                                    x: xmm,\n                                    y: ypp,\n                                    z: zmm\n                                }, {\n                                    x: xm,\n                                    y: yp,\n                                    z: zm\n                                }, {\n                                    x: xp,\n                                    y: yp,\n                                    z: zm\n                                }],\n                            enabled: frame.bottom.visible && !frame.front.visible\n                        },\n                        {\n                            fill: H.color(frame.bottom.color).get(),\n                            vertexes: [{\n                                    x: xmm,\n                                    y: ypp,\n                                    z: zpp\n                                }, {\n                                    x: xpp,\n                                    y: ypp,\n                                    z: zpp\n                                }, {\n                                    x: xp,\n                                    y: yp,\n                                    z: zp\n                                }, {\n                                    x: xm,\n                                    y: yp,\n                                    z: zp\n                                }],\n                            enabled: frame.bottom.visible && !frame.back.visible\n                        }]\n                });\n                this.frameShapes.top[verb]({\n                    'class': 'highcharts-3d-frame highcharts-3d-frame-top',\n                    zIndex: frame.top.frontFacing ? -1000 : 1000,\n                    faces: [{\n                            fill: H.color(frame.top.color).brighten(0.1).get(),\n                            vertexes: [{\n                                    x: xmm,\n                                    y: ymm,\n                                    z: zpp\n                                }, {\n                                    x: xpp,\n                                    y: ymm,\n                                    z: zpp\n                                }, {\n                                    x: xpp,\n                                    y: ymm,\n                                    z: zmm\n                                }, {\n                                    x: xmm,\n                                    y: ymm,\n                                    z: zmm\n                                }],\n                            enabled: frame.top.visible\n                        },\n                        {\n                            fill: H.color(frame.top.color).brighten(0.1).get(),\n                            vertexes: [{\n                                    x: xm,\n                                    y: ym,\n                                    z: zm\n                                }, {\n                                    x: xp,\n                                    y: ym,\n                                    z: zm\n                                }, {\n                                    x: xp,\n                                    y: ym,\n                                    z: zp\n                                }, {\n                                    x: xm,\n                                    y: ym,\n                                    z: zp\n                                }],\n                            enabled: frame.top.visible\n                        },\n                        {\n                            fill: H.color(frame.top.color).brighten(-0.1).get(),\n                            vertexes: [{\n                                    x: xmm,\n                                    y: ymm,\n                                    z: zpp\n                                }, {\n                                    x: xmm,\n                                    y: ymm,\n                                    z: zmm\n                                }, {\n                                    x: xm,\n                                    y: ym,\n                                    z: zm\n                                }, {\n                                    x: xm,\n                                    y: ym,\n                                    z: zp\n                                }],\n                            enabled: frame.top.visible && !frame.left.visible\n                        },\n                        {\n                            fill: H.color(frame.top.color).brighten(-0.1).get(),\n                            vertexes: [{\n                                    x: xpp,\n                                    y: ymm,\n                                    z: zmm\n                                }, {\n                                    x: xpp,\n                                    y: ymm,\n                                    z: zpp\n                                }, {\n                                    x: xp,\n                                    y: ym,\n                                    z: zp\n                                }, {\n                                    x: xp,\n                                    y: ym,\n                                    z: zm\n                                }],\n                            enabled: frame.top.visible && !frame.right.visible\n                        },\n                        {\n                            fill: H.color(frame.top.color).get(),\n                            vertexes: [{\n                                    x: xmm,\n                                    y: ymm,\n                                    z: zmm\n                                }, {\n                                    x: xpp,\n                                    y: ymm,\n                                    z: zmm\n                                }, {\n                                    x: xp,\n                                    y: ym,\n                                    z: zm\n                                }, {\n                                    x: xm,\n                                    y: ym,\n                                    z: zm\n                                }],\n                            enabled: frame.top.visible && !frame.front.visible\n                        },\n                        {\n                            fill: H.color(frame.top.color).get(),\n                            vertexes: [{\n                                    x: xpp,\n                                    y: ymm,\n                                    z: zpp\n                                }, {\n                                    x: xmm,\n                                    y: ymm,\n                                    z: zpp\n                                }, {\n                                    x: xm,\n                                    y: ym,\n                                    z: zp\n                                }, {\n                                    x: xp,\n                                    y: ym,\n                                    z: zp\n                                }],\n                            enabled: frame.top.visible && !frame.back.visible\n                        }]\n                });\n                this.frameShapes.left[verb]({\n                    'class': 'highcharts-3d-frame highcharts-3d-frame-left',\n                    zIndex: frame.left.frontFacing ? -1000 : 1000,\n                    faces: [{\n                            fill: H.color(frame.left.color).brighten(0.1).get(),\n                            vertexes: [{\n                                    x: xmm,\n                                    y: ypp,\n                                    z: zmm\n                                }, {\n                                    x: xm,\n                                    y: yp,\n                                    z: zm\n                                }, {\n                                    x: xm,\n                                    y: yp,\n                                    z: zp\n                                }, {\n                                    x: xmm,\n                                    y: ypp,\n                                    z: zpp\n                                }],\n                            enabled: frame.left.visible && !frame.bottom.visible\n                        },\n                        {\n                            fill: H.color(frame.left.color).brighten(0.1).get(),\n                            vertexes: [{\n                                    x: xmm,\n                                    y: ymm,\n                                    z: zpp\n                                }, {\n                                    x: xm,\n                                    y: ym,\n                                    z: zp\n                                }, {\n                                    x: xm,\n                                    y: ym,\n                                    z: zm\n                                }, {\n                                    x: xmm,\n                                    y: ymm,\n                                    z: zmm\n                                }],\n                            enabled: frame.left.visible && !frame.top.visible\n                        },\n                        {\n                            fill: H.color(frame.left.color).brighten(-0.1).get(),\n                            vertexes: [{\n                                    x: xmm,\n                                    y: ypp,\n                                    z: zpp\n                                }, {\n                                    x: xmm,\n                                    y: ymm,\n                                    z: zpp\n                                }, {\n                                    x: xmm,\n                                    y: ymm,\n                                    z: zmm\n                                }, {\n                                    x: xmm,\n                                    y: ypp,\n                                    z: zmm\n                                }],\n                            enabled: frame.left.visible\n                        },\n                        {\n                            fill: H.color(frame.left.color).brighten(-0.1).get(),\n                            vertexes: [{\n                                    x: xm,\n                                    y: ym,\n                                    z: zp\n                                }, {\n                                    x: xm,\n                                    y: yp,\n                                    z: zp\n                                }, {\n                                    x: xm,\n                                    y: yp,\n                                    z: zm\n                                }, {\n                                    x: xm,\n                                    y: ym,\n                                    z: zm\n                                }],\n                            enabled: frame.left.visible\n                        },\n                        {\n                            fill: H.color(frame.left.color).get(),\n                            vertexes: [{\n                                    x: xmm,\n                                    y: ypp,\n                                    z: zmm\n                                }, {\n                                    x: xmm,\n                                    y: ymm,\n                                    z: zmm\n                                }, {\n                                    x: xm,\n                                    y: ym,\n                                    z: zm\n                                }, {\n                                    x: xm,\n                                    y: yp,\n                                    z: zm\n                                }],\n                            enabled: frame.left.visible && !frame.front.visible\n                        },\n                        {\n                            fill: H.color(frame.left.color).get(),\n                            vertexes: [{\n                                    x: xmm,\n                                    y: ymm,\n                                    z: zpp\n                                }, {\n                                    x: xmm,\n                                    y: ypp,\n                                    z: zpp\n                                }, {\n                                    x: xm,\n                                    y: yp,\n                                    z: zp\n                                }, {\n                                    x: xm,\n                                    y: ym,\n                                    z: zp\n                                }],\n                            enabled: frame.left.visible && !frame.back.visible\n                        }]\n                });\n                this.frameShapes.right[verb]({\n                    'class': 'highcharts-3d-frame highcharts-3d-frame-right',\n                    zIndex: frame.right.frontFacing ? -1000 : 1000,\n                    faces: [{\n                            fill: H.color(frame.right.color).brighten(0.1).get(),\n                            vertexes: [{\n                                    x: xpp,\n                                    y: ypp,\n                                    z: zpp\n                                }, {\n                                    x: xp,\n                                    y: yp,\n                                    z: zp\n                                }, {\n                                    x: xp,\n                                    y: yp,\n                                    z: zm\n                                }, {\n                                    x: xpp,\n                                    y: ypp,\n                                    z: zmm\n                                }],\n                            enabled: frame.right.visible && !frame.bottom.visible\n                        },\n                        {\n                            fill: H.color(frame.right.color).brighten(0.1).get(),\n                            vertexes: [{\n                                    x: xpp,\n                                    y: ymm,\n                                    z: zmm\n                                }, {\n                                    x: xp,\n                                    y: ym,\n                                    z: zm\n                                }, {\n                                    x: xp,\n                                    y: ym,\n                                    z: zp\n                                }, {\n                                    x: xpp,\n                                    y: ymm,\n                                    z: zpp\n                                }],\n                            enabled: frame.right.visible && !frame.top.visible\n                        },\n                        {\n                            fill: H.color(frame.right.color).brighten(-0.1).get(),\n                            vertexes: [{\n                                    x: xp,\n                                    y: ym,\n                                    z: zm\n                                }, {\n                                    x: xp,\n                                    y: yp,\n                                    z: zm\n                                }, {\n                                    x: xp,\n                                    y: yp,\n                                    z: zp\n                                }, {\n                                    x: xp,\n                                    y: ym,\n                                    z: zp\n                                }],\n                            enabled: frame.right.visible\n                        },\n                        {\n                            fill: H.color(frame.right.color).brighten(-0.1).get(),\n                            vertexes: [{\n                                    x: xpp,\n                                    y: ypp,\n                                    z: zmm\n                                }, {\n                                    x: xpp,\n                                    y: ymm,\n                                    z: zmm\n                                }, {\n                                    x: xpp,\n                                    y: ymm,\n                                    z: zpp\n                                }, {\n                                    x: xpp,\n                                    y: ypp,\n                                    z: zpp\n                                }],\n                            enabled: frame.right.visible\n                        },\n                        {\n                            fill: H.color(frame.right.color).get(),\n                            vertexes: [{\n                                    x: xpp,\n                                    y: ymm,\n                                    z: zmm\n                                }, {\n                                    x: xpp,\n                                    y: ypp,\n                                    z: zmm\n                                }, {\n                                    x: xp,\n                                    y: yp,\n                                    z: zm\n                                }, {\n                                    x: xp,\n                                    y: ym,\n                                    z: zm\n                                }],\n                            enabled: frame.right.visible && !frame.front.visible\n                        },\n                        {\n                            fill: H.color(frame.right.color).get(),\n                            vertexes: [{\n                                    x: xpp,\n                                    y: ypp,\n                                    z: zpp\n                                }, {\n                                    x: xpp,\n                                    y: ymm,\n                                    z: zpp\n                                }, {\n                                    x: xp,\n                                    y: ym,\n                                    z: zp\n                                }, {\n                                    x: xp,\n                                    y: yp,\n                                    z: zp\n                                }],\n                            enabled: frame.right.visible && !frame.back.visible\n                        }]\n                });\n                this.frameShapes.back[verb]({\n                    'class': 'highcharts-3d-frame highcharts-3d-frame-back',\n                    zIndex: frame.back.frontFacing ? -1000 : 1000,\n                    faces: [{\n                            fill: H.color(frame.back.color).brighten(0.1).get(),\n                            vertexes: [{\n                                    x: xpp,\n                                    y: ypp,\n                                    z: zpp\n                                }, {\n                                    x: xmm,\n                                    y: ypp,\n                                    z: zpp\n                                }, {\n                                    x: xm,\n                                    y: yp,\n                                    z: zp\n                                }, {\n                                    x: xp,\n                                    y: yp,\n                                    z: zp\n                                }],\n                            enabled: frame.back.visible && !frame.bottom.visible\n                        },\n                        {\n                            fill: H.color(frame.back.color).brighten(0.1).get(),\n                            vertexes: [{\n                                    x: xmm,\n                                    y: ymm,\n                                    z: zpp\n                                }, {\n                                    x: xpp,\n                                    y: ymm,\n                                    z: zpp\n                                }, {\n                                    x: xp,\n                                    y: ym,\n                                    z: zp\n                                }, {\n                                    x: xm,\n                                    y: ym,\n                                    z: zp\n                                }],\n                            enabled: frame.back.visible && !frame.top.visible\n                        },\n                        {\n                            fill: H.color(frame.back.color).brighten(-0.1).get(),\n                            vertexes: [{\n                                    x: xmm,\n                                    y: ypp,\n                                    z: zpp\n                                }, {\n                                    x: xmm,\n                                    y: ymm,\n                                    z: zpp\n                                }, {\n                                    x: xm,\n                                    y: ym,\n                                    z: zp\n                                }, {\n                                    x: xm,\n                                    y: yp,\n                                    z: zp\n                                }],\n                            enabled: frame.back.visible && !frame.left.visible\n                        },\n                        {\n                            fill: H.color(frame.back.color).brighten(-0.1).get(),\n                            vertexes: [{\n                                    x: xpp,\n                                    y: ymm,\n                                    z: zpp\n                                }, {\n                                    x: xpp,\n                                    y: ypp,\n                                    z: zpp\n                                }, {\n                                    x: xp,\n                                    y: yp,\n                                    z: zp\n                                }, {\n                                    x: xp,\n                                    y: ym,\n                                    z: zp\n                                }],\n                            enabled: frame.back.visible && !frame.right.visible\n                        },\n                        {\n                            fill: H.color(frame.back.color).get(),\n                            vertexes: [{\n                                    x: xm,\n                                    y: ym,\n                                    z: zp\n                                }, {\n                                    x: xp,\n                                    y: ym,\n                                    z: zp\n                                }, {\n                                    x: xp,\n                                    y: yp,\n                                    z: zp\n                                }, {\n                                    x: xm,\n                                    y: yp,\n                                    z: zp\n                                }],\n                            enabled: frame.back.visible\n                        },\n                        {\n                            fill: H.color(frame.back.color).get(),\n                            vertexes: [{\n                                    x: xmm,\n                                    y: ypp,\n                                    z: zpp\n                                }, {\n                                    x: xpp,\n                                    y: ypp,\n                                    z: zpp\n                                }, {\n                                    x: xpp,\n                                    y: ymm,\n                                    z: zpp\n                                }, {\n                                    x: xmm,\n                                    y: ymm,\n                                    z: zpp\n                                }],\n                            enabled: frame.back.visible\n                        }]\n                });\n                this.frameShapes.front[verb]({\n                    'class': 'highcharts-3d-frame highcharts-3d-frame-front',\n                    zIndex: frame.front.frontFacing ? -1000 : 1000,\n                    faces: [{\n                            fill: H.color(frame.front.color).brighten(0.1).get(),\n                            vertexes: [{\n                                    x: xmm,\n                                    y: ypp,\n                                    z: zmm\n                                }, {\n                                    x: xpp,\n                                    y: ypp,\n                                    z: zmm\n                                }, {\n                                    x: xp,\n                                    y: yp,\n                                    z: zm\n                                }, {\n                                    x: xm,\n                                    y: yp,\n                                    z: zm\n                                }],\n                            enabled: frame.front.visible && !frame.bottom.visible\n                        },\n                        {\n                            fill: H.color(frame.front.color).brighten(0.1).get(),\n                            vertexes: [{\n                                    x: xpp,\n                                    y: ymm,\n                                    z: zmm\n                                }, {\n                                    x: xmm,\n                                    y: ymm,\n                                    z: zmm\n                                }, {\n                                    x: xm,\n                                    y: ym,\n                                    z: zm\n                                }, {\n                                    x: xp,\n                                    y: ym,\n                                    z: zm\n                                }],\n                            enabled: frame.front.visible && !frame.top.visible\n                        },\n                        {\n                            fill: H.color(frame.front.color).brighten(-0.1).get(),\n                            vertexes: [{\n                                    x: xmm,\n                                    y: ymm,\n                                    z: zmm\n                                }, {\n                                    x: xmm,\n                                    y: ypp,\n                                    z: zmm\n                                }, {\n                                    x: xm,\n                                    y: yp,\n                                    z: zm\n                                }, {\n                                    x: xm,\n                                    y: ym,\n                                    z: zm\n                                }],\n                            enabled: frame.front.visible && !frame.left.visible\n                        },\n                        {\n                            fill: H.color(frame.front.color).brighten(-0.1).get(),\n                            vertexes: [{\n                                    x: xpp,\n                                    y: ypp,\n                                    z: zmm\n                                }, {\n                                    x: xpp,\n                                    y: ymm,\n                                    z: zmm\n                                }, {\n                                    x: xp,\n                                    y: ym,\n                                    z: zm\n                                }, {\n                                    x: xp,\n                                    y: yp,\n                                    z: zm\n                                }],\n                            enabled: frame.front.visible && !frame.right.visible\n                        },\n                        {\n                            fill: H.color(frame.front.color).get(),\n                            vertexes: [{\n                                    x: xp,\n                                    y: ym,\n                                    z: zm\n                                }, {\n                                    x: xm,\n                                    y: ym,\n                                    z: zm\n                                }, {\n                                    x: xm,\n                                    y: yp,\n                                    z: zm\n                                }, {\n                                    x: xp,\n                                    y: yp,\n                                    z: zm\n                                }],\n                            enabled: frame.front.visible\n                        },\n                        {\n                            fill: H.color(frame.front.color).get(),\n                            vertexes: [{\n                                    x: xpp,\n                                    y: ypp,\n                                    z: zmm\n                                }, {\n                                    x: xmm,\n                                    y: ypp,\n                                    z: zmm\n                                }, {\n                                    x: xmm,\n                                    y: ymm,\n                                    z: zmm\n                                }, {\n                                    x: xpp,\n                                    y: ymm,\n                                    z: zmm\n                                }],\n                            enabled: frame.front.visible\n                        }]\n                });\n            }\n        });\n        Chart.prototype.retrieveStacks = function (stacking) {\n            var series = this.series,\n                stacks = {},\n                stackNumber,\n                i = 1;\n            this.series.forEach(function (s) {\n                stackNumber = pick(s.options.stack, (stacking ? 0 : series.length - 1 - s.index)); // #3841, #4532\n                if (!stacks[stackNumber]) {\n                    stacks[stackNumber] = { series: [s], position: i };\n                    i++;\n                }\n                else {\n                    stacks[stackNumber].series.push(s);\n                }\n            });\n            stacks.totalStacks = i + 1;\n            return stacks;\n        };\n        Chart.prototype.get3dFrame = function () {\n            var chart = this,\n                options3d = chart.options.chart.options3d,\n                frameOptions = options3d.frame,\n                xm = chart.plotLeft,\n                xp = chart.plotLeft + chart.plotWidth,\n                ym = chart.plotTop,\n                yp = chart.plotTop + chart.plotHeight,\n                zm = 0,\n                zp = options3d.depth,\n                faceOrientation = function (vertexes) {\n                    var area = H.shapeArea3d(vertexes,\n                chart);\n                // Give it 0.5 squared-pixel as a margin for rounding errors.\n                if (area > 0.5) {\n                    return 1;\n                }\n                if (area < -0.5) {\n                    return -1;\n                }\n                return 0;\n            }, bottomOrientation = faceOrientation([\n                { x: xm, y: yp, z: zp },\n                { x: xp, y: yp, z: zp },\n                { x: xp, y: yp, z: zm },\n                { x: xm, y: yp, z: zm }\n            ]), topOrientation = faceOrientation([\n                { x: xm, y: ym, z: zm },\n                { x: xp, y: ym, z: zm },\n                { x: xp, y: ym, z: zp },\n                { x: xm, y: ym, z: zp }\n            ]), leftOrientation = faceOrientation([\n                { x: xm, y: ym, z: zm },\n                { x: xm, y: ym, z: zp },\n                { x: xm, y: yp, z: zp },\n                { x: xm, y: yp, z: zm }\n            ]), rightOrientation = faceOrientation([\n                { x: xp, y: ym, z: zp },\n                { x: xp, y: ym, z: zm },\n                { x: xp, y: yp, z: zm },\n                { x: xp, y: yp, z: zp }\n            ]), frontOrientation = faceOrientation([\n                { x: xm, y: yp, z: zm },\n                { x: xp, y: yp, z: zm },\n                { x: xp, y: ym, z: zm },\n                { x: xm, y: ym, z: zm }\n            ]), backOrientation = faceOrientation([\n                { x: xm, y: ym, z: zp },\n                { x: xp, y: ym, z: zp },\n                { x: xp, y: yp, z: zp },\n                { x: xm, y: yp, z: zp }\n            ]), defaultShowBottom = false, defaultShowTop = false, defaultShowLeft = false, defaultShowRight = false, defaultShowFront = false, defaultShowBack = true;\n            // The 'default' criteria to visible faces of the frame is looking up every\n            // axis to decide whenever the left/right//top/bottom sides of the frame\n            // will be shown\n            []\n                .concat(chart.xAxis, chart.yAxis, chart.zAxis)\n                .forEach(function (axis) {\n                if (axis) {\n                    if (axis.horiz) {\n                        if (axis.opposite) {\n                            defaultShowTop = true;\n                        }\n                        else {\n                            defaultShowBottom = true;\n                        }\n                    }\n                    else {\n                        if (axis.opposite) {\n                            defaultShowRight = true;\n                        }\n                        else {\n                            defaultShowLeft = true;\n                        }\n                    }\n                }\n            });\n            var getFaceOptions = function (sources, faceOrientation, defaultVisible) {\n                    var faceAttrs = ['size', 'color', 'visible'];\n                var options = {};\n                for (var i = 0; i < faceAttrs.length; i++) {\n                    var attr = faceAttrs[i];\n                    for (var j = 0; j < sources.length; j++) {\n                        if (typeof sources[j] === 'object') {\n                            var val = sources[j][attr];\n                            if (typeof val !== 'undefined' && val !== null) {\n                                options[attr] = val;\n                                break;\n                            }\n                        }\n                    }\n                }\n                var isVisible = defaultVisible;\n                if (options.visible === true || options.visible === false) {\n                    isVisible = options.visible;\n                }\n                else if (options.visible === 'auto') {\n                    isVisible = faceOrientation > 0;\n                }\n                return {\n                    size: pick(options.size, 1),\n                    color: pick(options.color, 'none'),\n                    frontFacing: faceOrientation > 0,\n                    visible: isVisible\n                };\n            };\n            // docs @TODO: Add all frame options (left, right, top, bottom, front, back)\n            // to apioptions JSDoc once the new system is up.\n            var ret = {\n                    axes: {},\n                    // FIXME: Previously, left/right, top/bottom and front/back pairs shared\n                    // size and color.\n                    // For compatibility and consistency sake, when one face have\n                    // size/color/visibility set, the opposite face will default to the same\n                    // values. Also, left/right used to be called 'side', so that's also\n                    // added as a fallback\n                    bottom: getFaceOptions([frameOptions.bottom, frameOptions.top, frameOptions], bottomOrientation, defaultShowBottom),\n                    top: getFaceOptions([frameOptions.top, frameOptions.bottom, frameOptions], topOrientation, defaultShowTop),\n                    left: getFaceOptions([\n                        frameOptions.left,\n                        frameOptions.right,\n                        frameOptions.side,\n                        frameOptions\n                    ], leftOrientation, defaultShowLeft),\n                    right: getFaceOptions([\n                        frameOptions.right,\n                        frameOptions.left,\n                        frameOptions.side,\n                        frameOptions\n                    ], rightOrientation, defaultShowRight),\n                    back: getFaceOptions([frameOptions.back, frameOptions.front, frameOptions], backOrientation, defaultShowBack),\n                    front: getFaceOptions([frameOptions.front, frameOptions.back, frameOptions], frontOrientation, defaultShowFront)\n                };\n            // Decide the bast place to put axis title/labels based on the visible\n            // faces. Ideally, The labels can only be on the edge between a visible face\n            // and an invisble one. Also, the Y label should be one the left-most edge\n            // (right-most if opposite),\n            if (options3d.axisLabelPosition === 'auto') {\n                var isValidEdge = function (face1,\n                    face2) {\n                        return ((face1.visible !== face2.visible) ||\n                            (face1.visible &&\n                                face2.visible &&\n                                (face1.frontFacing !== face2.frontFacing)));\n                };\n                var yEdges = [];\n                if (isValidEdge(ret.left, ret.front)) {\n                    yEdges.push({\n                        y: (ym + yp) / 2,\n                        x: xm,\n                        z: zm,\n                        xDir: { x: 1, y: 0, z: 0 }\n                    });\n                }\n                if (isValidEdge(ret.left, ret.back)) {\n                    yEdges.push({\n                        y: (ym + yp) / 2,\n                        x: xm,\n                        z: zp,\n                        xDir: { x: 0, y: 0, z: -1 }\n                    });\n                }\n                if (isValidEdge(ret.right, ret.front)) {\n                    yEdges.push({\n                        y: (ym + yp) / 2,\n                        x: xp,\n                        z: zm,\n                        xDir: { x: 0, y: 0, z: 1 }\n                    });\n                }\n                if (isValidEdge(ret.right, ret.back)) {\n                    yEdges.push({\n                        y: (ym + yp) / 2,\n                        x: xp,\n                        z: zp,\n                        xDir: { x: -1, y: 0, z: 0 }\n                    });\n                }\n                var xBottomEdges = [];\n                if (isValidEdge(ret.bottom, ret.front)) {\n                    xBottomEdges.push({\n                        x: (xm + xp) / 2,\n                        y: yp,\n                        z: zm,\n                        xDir: { x: 1, y: 0, z: 0 }\n                    });\n                }\n                if (isValidEdge(ret.bottom, ret.back)) {\n                    xBottomEdges.push({\n                        x: (xm + xp) / 2,\n                        y: yp,\n                        z: zp,\n                        xDir: { x: -1, y: 0, z: 0 }\n                    });\n                }\n                var xTopEdges = [];\n                if (isValidEdge(ret.top, ret.front)) {\n                    xTopEdges.push({\n                        x: (xm + xp) / 2,\n                        y: ym,\n                        z: zm,\n                        xDir: { x: 1, y: 0, z: 0 }\n                    });\n                }\n                if (isValidEdge(ret.top, ret.back)) {\n                    xTopEdges.push({\n                        x: (xm + xp) / 2,\n                        y: ym,\n                        z: zp,\n                        xDir: { x: -1, y: 0, z: 0 }\n                    });\n                }\n                var zBottomEdges = [];\n                if (isValidEdge(ret.bottom, ret.left)) {\n                    zBottomEdges.push({\n                        z: (zm + zp) / 2,\n                        y: yp,\n                        x: xm,\n                        xDir: { x: 0, y: 0, z: -1 }\n                    });\n                }\n                if (isValidEdge(ret.bottom, ret.right)) {\n                    zBottomEdges.push({\n                        z: (zm + zp) / 2,\n                        y: yp,\n                        x: xp,\n                        xDir: { x: 0, y: 0, z: 1 }\n                    });\n                }\n                var zTopEdges = [];\n                if (isValidEdge(ret.top, ret.left)) {\n                    zTopEdges.push({\n                        z: (zm + zp) / 2,\n                        y: ym,\n                        x: xm,\n                        xDir: { x: 0, y: 0, z: -1 }\n                    });\n                }\n                if (isValidEdge(ret.top, ret.right)) {\n                    zTopEdges.push({\n                        z: (zm + zp) / 2,\n                        y: ym,\n                        x: xp,\n                        xDir: { x: 0, y: 0, z: 1 }\n                    });\n                }\n                var pickEdge = function (edges,\n                    axis,\n                    mult) {\n                        if (edges.length === 0) {\n                            return null;\n                    }\n                    if (edges.length === 1) {\n                        return edges[0];\n                    }\n                    var best = 0,\n                        projections = perspective(edges,\n                        chart,\n                        false);\n                    for (var i = 1; i < projections.length; i++) {\n                        if (mult * projections[i][axis] >\n                            mult * projections[best][axis]) {\n                            best = i;\n                        }\n                        else if ((mult * projections[i][axis] ===\n                            mult * projections[best][axis]) &&\n                            (projections[i].z < projections[best].z)) {\n                            best = i;\n                        }\n                    }\n                    return edges[best];\n                };\n                ret.axes = {\n                    y: {\n                        'left': pickEdge(yEdges, 'x', -1),\n                        'right': pickEdge(yEdges, 'x', +1)\n                    },\n                    x: {\n                        'top': pickEdge(xTopEdges, 'y', -1),\n                        'bottom': pickEdge(xBottomEdges, 'y', +1)\n                    },\n                    z: {\n                        'top': pickEdge(zTopEdges, 'y', -1),\n                        'bottom': pickEdge(zBottomEdges, 'y', +1)\n                    }\n                };\n            }\n            else {\n                ret.axes = {\n                    y: {\n                        'left': { x: xm, z: zm, xDir: { x: 1, y: 0, z: 0 } },\n                        'right': { x: xp, z: zm, xDir: { x: 0, y: 0, z: 1 } }\n                    },\n                    x: {\n                        'top': { y: ym, z: zm, xDir: { x: 1, y: 0, z: 0 } },\n                        'bottom': { y: yp, z: zm, xDir: { x: 1, y: 0, z: 0 } }\n                    },\n                    z: {\n                        'top': {\n                            x: defaultShowLeft ? xp : xm,\n                            y: ym,\n                            xDir: defaultShowLeft ?\n                                { x: 0, y: 0, z: 1 } :\n                                { x: 0, y: 0, z: -1 }\n                        },\n                        'bottom': {\n                            x: defaultShowLeft ? xp : xm,\n                            y: yp,\n                            xDir: defaultShowLeft ?\n                                { x: 0, y: 0, z: 1 } :\n                                { x: 0, y: 0, z: -1 }\n                        }\n                    }\n                };\n            }\n            return ret;\n        };\n        // Animation setter for matrix property.\n        H.Fx.prototype.matrixSetter = function () {\n            var interpolated;\n            if (this.pos < 1 &&\n                (isArray(this.start) || isArray(this.end))) {\n                var start = this.start || [1, 0, 0, 1, 0, 0];\n                var end = this.end || [1, 0, 0, 1, 0, 0];\n                interpolated = [];\n                for (var i = 0; i < 6; i++) {\n                    interpolated.push(this.pos * end[i] + (1 - this.pos) * start[i]);\n                }\n            }\n            else {\n                interpolated = this.end;\n            }\n            this.elem.attr(this.prop, interpolated, null, true);\n        };\n        /**\n         * Note: As of v5.0.12, `frame.left` or `frame.right` should be used instead.\n         *\n         * The side for the frame around a 3D chart.\n         *\n         * @deprecated\n         * @since     4.0\n         * @product   highcharts\n         * @requires  highcharts-3d\n         * @apioption chart.options3d.frame.side\n         */\n        /**\n         * The color of the panel.\n         *\n         * @deprecated\n         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n         * @default   transparent\n         * @since     4.0\n         * @product   highcharts\n         * @apioption chart.options3d.frame.side.color\n         */\n        /**\n         * The thickness of the panel.\n         *\n         * @deprecated\n         * @type      {number}\n         * @default   1\n         * @since     4.0\n         * @product   highcharts\n         * @apioption chart.options3d.frame.side.size\n         */\n        ''; // adds doclets above to transpiled file\n\n    });\n    _registerModule(_modules, 'parts-3d/Axis.js', [_modules['parts/Globals.js'], _modules['parts/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  (c) 2010-2019 Torstein Honsi\n         *\n         *  Extenstion for 3d axes\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var extend = U.extend,\n            pick = U.pick,\n            splat = U.splat,\n            wrap = U.wrap;\n        var ZAxis,\n            addEvent = H.addEvent,\n            Axis = H.Axis,\n            Chart = H.Chart,\n            deg2rad = H.deg2rad,\n            merge = H.merge,\n            perspective = H.perspective,\n            perspective3D = H.perspective3D,\n            shapeArea = H.shapeArea,\n            Tick = H.Tick;\n        /**\n         * @optionparent xAxis\n         */\n        var extendedOptions = {\n                labels: {\n                    /**\n                     * Defines how the labels are be repositioned according to the 3D chart\n                     * orientation.\n                     *\n                     * - `'offset'`: Maintain a fixed horizontal/vertical distance from the\n                     *   tick marks, despite the chart orientation. This is the backwards\n                     *   compatible behavior, and causes skewing of X and Z axes.\n                     *\n                     * - `'chart'`: Preserve 3D position relative to the chart.\n                     *   This looks nice, but hard to read if the text isn't\n                     *   forward-facing.\n                     *\n                     * - `'flap'`: Rotated text along the axis to compensate for the chart\n                     *   orientation. This tries to maintain text as legible as possible\n                     *   on all orientations.\n                     *\n                     * - `'ortho'`: Rotated text along the axis direction so that the labels\n                     *   are orthogonal to the axis. This is very similar to `'flap'`,\n                     *   but prevents skewing the labels (X and Y scaling are still\n                     *   present).\n                     *\n                     * @sample highcharts/3d/skewed-labels/\n                     *         Skewed labels\n                     *\n                     * @since      5.0.15\n                     * @validvalue ['offset', 'chart', 'flap', 'ortho']\n                     * @product    highcharts\n                     * @requires   highcharts-3d\n                     */\n                    position3d: 'offset',\n                    /**\n                     * If enabled, the axis labels will skewed to follow the perspective.\n                     *\n                     * This will fix overlapping labels and titles, but texts become less\n                     * legible due to the distortion.\n                     *\n                     * The final appearance depends heavily on `labels.position3d`.\n                     *\n                     * @sample highcharts/3d/skewed-labels/\n                     *         Skewed labels\n                     *\n                     * @since    5.0.15\n                     * @product  highcharts\n                     * @requires highcharts-3d\n                     */\n                    skew3d: false\n                },\n                title: {\n                    /**\n                     * Defines how the title is repositioned according to the 3D chart\n                     * orientation.\n                     *\n                     * - `'offset'`: Maintain a fixed horizontal/vertical distance from the\n                     *   tick marks, despite the chart orientation. This is the backwards\n                     *   compatible behavior, and causes skewing of X and Z axes.\n                     *\n                     * - `'chart'`: Preserve 3D position relative to the chart.\n                     *   This looks nice, but hard to read if the text isn't\n                     *   forward-facing.\n                     *\n                     * - `'flap'`: Rotated text along the axis to compensate for the chart\n                     *   orientation. This tries to maintain text as legible as possible on\n                     *   all orientations.\n                     *\n                     * - `'ortho'`: Rotated text along the axis direction so that the labels\n                     *   are orthogonal to the axis. This is very similar to `'flap'`, but\n                     *   prevents skewing the labels (X and Y scaling are still present).\n                     *\n                     * - `undefined`: Will use the config from `labels.position3d`\n                     *\n                     * @sample highcharts/3d/skewed-labels/\n                     *         Skewed labels\n                     *\n                     * @type     {\"offset\"|\"chart\"|\"flap\"|\"ortho\"|null}\n                     * @since    5.0.15\n                     * @product  highcharts\n                     * @requires highcharts-3d\n                     */\n                    position3d: null,\n                    /**\n                     * If enabled, the axis title will skewed to follow the perspective.\n                     *\n                     * This will fix overlapping labels and titles, but texts become less\n                     * legible due to the distortion.\n                     *\n                     * The final appearance depends heavily on `title.position3d`.\n                     *\n                     * A `null` value will use the config from `labels.skew3d`.\n                     *\n                     * @sample highcharts/3d/skewed-labels/\n                     *         Skewed labels\n                     *\n                     * @type     {boolean|null}\n                     * @since    5.0.15\n                     * @product  highcharts\n                     * @requires highcharts-3d\n                     */\n                    skew3d: null\n                }\n            };\n        /* eslint-disable no-invalid-this */\n        merge(true, Axis.prototype.defaultOptions, extendedOptions);\n        addEvent(Axis, 'afterSetOptions', function () {\n            var options;\n            if (this.chart.is3d && this.chart.is3d() && this.coll !== 'colorAxis') {\n                options = this.options;\n                options.tickWidth = pick(options.tickWidth, 0);\n                options.gridLineWidth = pick(options.gridLineWidth, 1);\n            }\n        });\n        wrap(Axis.prototype, 'getPlotLinePath', function (proceed) {\n            var path = proceed.apply(this,\n                [].slice.call(arguments, 1));\n            // Do not do this if the chart is not 3D\n            if (!this.chart.is3d() || this.coll === 'colorAxis') {\n                return path;\n            }\n            if (path === null) {\n                return path;\n            }\n            var chart = this.chart,\n                options3d = chart.options.chart.options3d,\n                d = this.isZAxis ? chart.plotWidth : options3d.depth,\n                frame = chart.frame3d;\n            var pArr = [\n                    this.swapZ({ x: path[1],\n                y: path[2],\n                z: 0 }),\n                    this.swapZ({ x: path[1],\n                y: path[2],\n                z: d }),\n                    this.swapZ({ x: path[4],\n                y: path[5],\n                z: 0 }),\n                    this.swapZ({ x: path[4],\n                y: path[5],\n                z: d })\n                ];\n            var pathSegments = [];\n            if (!this.horiz) { // Y-Axis\n                if (frame.front.visible) {\n                    pathSegments.push(pArr[0], pArr[2]);\n                }\n                if (frame.back.visible) {\n                    pathSegments.push(pArr[1], pArr[3]);\n                }\n                if (frame.left.visible) {\n                    pathSegments.push(pArr[0], pArr[1]);\n                }\n                if (frame.right.visible) {\n                    pathSegments.push(pArr[2], pArr[3]);\n                }\n            }\n            else if (this.isZAxis) { // Z-Axis\n                if (frame.left.visible) {\n                    pathSegments.push(pArr[0], pArr[2]);\n                }\n                if (frame.right.visible) {\n                    pathSegments.push(pArr[1], pArr[3]);\n                }\n                if (frame.top.visible) {\n                    pathSegments.push(pArr[0], pArr[1]);\n                }\n                if (frame.bottom.visible) {\n                    pathSegments.push(pArr[2], pArr[3]);\n                }\n            }\n            else { // X-Axis\n                if (frame.front.visible) {\n                    pathSegments.push(pArr[0], pArr[2]);\n                }\n                if (frame.back.visible) {\n                    pathSegments.push(pArr[1], pArr[3]);\n                }\n                if (frame.top.visible) {\n                    pathSegments.push(pArr[0], pArr[1]);\n                }\n                if (frame.bottom.visible) {\n                    pathSegments.push(pArr[2], pArr[3]);\n                }\n            }\n            pathSegments = perspective(pathSegments, this.chart, false);\n            return this.chart.renderer.toLineSegments(pathSegments);\n        });\n        // Do not draw axislines in 3D\n        wrap(Axis.prototype, 'getLinePath', function (proceed) {\n            // Do not do this if the chart is not 3D\n            if (!this.chart.is3d() || this.coll === 'colorAxis') {\n                return proceed.apply(this, [].slice.call(arguments, 1));\n            }\n            return [];\n        });\n        wrap(Axis.prototype, 'getPlotBandPath', function (proceed) {\n            // Do not do this if the chart is not 3D\n            if (!this.chart.is3d() || this.coll === 'colorAxis') {\n                return proceed.apply(this, [].slice.call(arguments, 1));\n            }\n            var args = arguments,\n                from = args[1],\n                to = args[2],\n                path = [],\n                fromPath = this.getPlotLinePath({ value: from }),\n                toPath = this.getPlotLinePath({ value: to });\n            if (fromPath && toPath) {\n                for (var i = 0; i < fromPath.length; i += 6) {\n                    path.push('M', fromPath[i + 1], fromPath[i + 2], 'L', fromPath[i + 4], fromPath[i + 5], 'L', toPath[i + 4], toPath[i + 5], 'L', toPath[i + 1], toPath[i + 2], 'Z');\n                }\n            }\n            return path;\n        });\n        /**\n         * @private\n         * @param {Highcharts.Axis} axis\n         *        Related axis\n         * @param {Highcharts.Position3dObject} pos\n         *        Position to fix\n         * @param {boolean} [isTitle]\n         *        Whether this is a title position\n         * @return {Highcharts.Position3dObject}\n         *         Fixed position\n         */\n        function fix3dPosition(axis, pos, isTitle) {\n            // Do not do this if the chart is not 3D\n            if (!axis.chart.is3d() || axis.coll === 'colorAxis') {\n                return pos;\n            }\n            var chart = axis.chart,\n                alpha = deg2rad * chart.options.chart.options3d.alpha,\n                beta = deg2rad * chart.options.chart.options3d.beta,\n                positionMode = pick(isTitle && axis.options.title.position3d,\n                axis.options.labels.position3d),\n                skew = pick(isTitle && axis.options.title.skew3d,\n                axis.options.labels.skew3d),\n                frame = chart.frame3d,\n                plotLeft = chart.plotLeft,\n                plotRight = chart.plotWidth + plotLeft,\n                plotTop = chart.plotTop,\n                plotBottom = chart.plotHeight + plotTop, \n                // Indicates we are labelling an X or Z axis on the \"back\" of the chart\n                reverseFlap = false,\n                offsetX = 0,\n                offsetY = 0,\n                vecX,\n                vecY = { x: 0,\n                y: 1,\n                z: 0 };\n            pos = axis.swapZ({ x: pos.x, y: pos.y, z: 0 });\n            if (axis.isZAxis) { // Z Axis\n                if (axis.opposite) {\n                    if (frame.axes.z.top === null) {\n                        return {};\n                    }\n                    offsetY = pos.y - plotTop;\n                    pos.x = frame.axes.z.top.x;\n                    pos.y = frame.axes.z.top.y;\n                    vecX = frame.axes.z.top.xDir;\n                    reverseFlap = !frame.top.frontFacing;\n                }\n                else {\n                    if (frame.axes.z.bottom === null) {\n                        return {};\n                    }\n                    offsetY = pos.y - plotBottom;\n                    pos.x = frame.axes.z.bottom.x;\n                    pos.y = frame.axes.z.bottom.y;\n                    vecX = frame.axes.z.bottom.xDir;\n                    reverseFlap = !frame.bottom.frontFacing;\n                }\n            }\n            else if (axis.horiz) { // X Axis\n                if (axis.opposite) {\n                    if (frame.axes.x.top === null) {\n                        return {};\n                    }\n                    offsetY = pos.y - plotTop;\n                    pos.y = frame.axes.x.top.y;\n                    pos.z = frame.axes.x.top.z;\n                    vecX = frame.axes.x.top.xDir;\n                    reverseFlap = !frame.top.frontFacing;\n                }\n                else {\n                    if (frame.axes.x.bottom === null) {\n                        return {};\n                    }\n                    offsetY = pos.y - plotBottom;\n                    pos.y = frame.axes.x.bottom.y;\n                    pos.z = frame.axes.x.bottom.z;\n                    vecX = frame.axes.x.bottom.xDir;\n                    reverseFlap = !frame.bottom.frontFacing;\n                }\n            }\n            else { // Y Axis\n                if (axis.opposite) {\n                    if (frame.axes.y.right === null) {\n                        return {};\n                    }\n                    offsetX = pos.x - plotRight;\n                    pos.x = frame.axes.y.right.x;\n                    pos.z = frame.axes.y.right.z;\n                    vecX = frame.axes.y.right.xDir;\n                    // Rotate 90º on opposite edge\n                    vecX = { x: vecX.z, y: vecX.y, z: -vecX.x };\n                }\n                else {\n                    if (frame.axes.y.left === null) {\n                        return {};\n                    }\n                    offsetX = pos.x - plotLeft;\n                    pos.x = frame.axes.y.left.x;\n                    pos.z = frame.axes.y.left.z;\n                    vecX = frame.axes.y.left.xDir;\n                }\n            }\n            if (positionMode === 'chart') {\n                // Labels preserve their direction relative to the chart\n                // nothing to do\n            }\n            else if (positionMode === 'flap') {\n                // Labels are be rotated around the axis direction to face the screen\n                if (!axis.horiz) { // Y Axis\n                    vecX = { x: Math.cos(beta), y: 0, z: Math.sin(beta) };\n                }\n                else { // X and Z Axis\n                    var sin = Math.sin(alpha);\n                    var cos = Math.cos(alpha);\n                    if (axis.opposite) {\n                        sin = -sin;\n                    }\n                    if (reverseFlap) {\n                        sin = -sin;\n                    }\n                    vecY = { x: vecX.z * sin, y: cos, z: -vecX.x * sin };\n                }\n            }\n            else if (positionMode === 'ortho') {\n                // Labels will be rotated to be ortogonal to the axis\n                if (!axis.horiz) { // Y Axis\n                    vecX = { x: Math.cos(beta), y: 0, z: Math.sin(beta) };\n                }\n                else { // X and Z Axis\n                    var sina = Math.sin(alpha);\n                    var cosa = Math.cos(alpha);\n                    var sinb = Math.sin(beta);\n                    var cosb = Math.cos(beta);\n                    var vecZ = { x: sinb * cosa,\n                        y: -sina,\n                        z: -cosa * cosb };\n                    vecY = {\n                        x: vecX.y * vecZ.z - vecX.z * vecZ.y,\n                        y: vecX.z * vecZ.x - vecX.x * vecZ.z,\n                        z: vecX.x * vecZ.y - vecX.y * vecZ.x\n                    };\n                    var scale = 1 / Math.sqrt(vecY.x * vecY.x + vecY.y * vecY.y + vecY.z * vecY.z);\n                    if (reverseFlap) {\n                        scale = -scale;\n                    }\n                    vecY = { x: scale * vecY.x, y: scale * vecY.y, z: scale * vecY.z };\n                }\n            }\n            else { // positionMode  == 'offset'\n                // Labels will be skewd to maintain vertical / horizontal offsets from\n                // axis\n                if (!axis.horiz) { // Y Axis\n                    vecX = { x: Math.cos(beta), y: 0, z: Math.sin(beta) };\n                }\n                else { // X and Z Axis\n                    vecY = {\n                        x: Math.sin(beta) * Math.sin(alpha),\n                        y: Math.cos(alpha),\n                        z: -Math.cos(beta) * Math.sin(alpha)\n                    };\n                }\n            }\n            pos.x += offsetX * vecX.x + offsetY * vecY.x;\n            pos.y += offsetX * vecX.y + offsetY * vecY.y;\n            pos.z += offsetX * vecX.z + offsetY * vecY.z;\n            var projected = perspective([pos],\n                axis.chart)[0];\n            if (skew) {\n                // Check if the label text would be mirrored\n                var isMirrored = shapeArea(perspective([\n                        pos,\n                        { x: pos.x + vecX.x,\n                    y: pos.y + vecX.y,\n                    z: pos.z + vecX.z },\n                        { x: pos.x + vecY.x,\n                    y: pos.y + vecY.y,\n                    z: pos.z + vecY.z }\n                    ],\n                    axis.chart)) < 0;\n                if (isMirrored) {\n                    vecX = { x: -vecX.x, y: -vecX.y, z: -vecX.z };\n                }\n                var pointsProjected = perspective([\n                        { x: pos.x,\n                    y: pos.y,\n                    z: pos.z },\n                        { x: pos.x + vecX.x,\n                    y: pos.y + vecX.y,\n                    z: pos.z + vecX.z },\n                        { x: pos.x + vecY.x,\n                    y: pos.y + vecY.y,\n                    z: pos.z + vecY.z }\n                    ],\n                    axis.chart);\n                projected.matrix = [\n                    pointsProjected[1].x - pointsProjected[0].x,\n                    pointsProjected[1].y - pointsProjected[0].y,\n                    pointsProjected[2].x - pointsProjected[0].x,\n                    pointsProjected[2].y - pointsProjected[0].y,\n                    projected.x,\n                    projected.y\n                ];\n                projected.matrix[4] -= projected.x * projected.matrix[0] +\n                    projected.y * projected.matrix[2];\n                projected.matrix[5] -= projected.x * projected.matrix[1] +\n                    projected.y * projected.matrix[3];\n            }\n            return projected;\n        }\n        /*\n        Tick extensions\n         */\n        wrap(Tick.prototype, 'getMarkPath', function (proceed) {\n            var path = proceed.apply(this,\n                [].slice.call(arguments, 1));\n            var pArr = [\n                    fix3dPosition(this.axis, { x: path[1],\n                y: path[2],\n                z: 0 }),\n                    fix3dPosition(this.axis, { x: path[4],\n                y: path[5],\n                z: 0 })\n                ];\n            return this.axis.chart.renderer.toLineSegments(pArr);\n        });\n        addEvent(Tick, 'afterGetLabelPosition', function (e) {\n            extend(e.pos, fix3dPosition(this.axis, e.pos));\n        });\n        wrap(Axis.prototype, 'getTitlePosition', function (proceed) {\n            var pos = proceed.apply(this,\n                [].slice.call(arguments, 1));\n            return fix3dPosition(this, pos, true);\n        });\n        addEvent(Axis, 'drawCrosshair', function (e) {\n            if (this.chart.is3d() && this.coll !== 'colorAxis') {\n                if (e.point) {\n                    e.point.crosshairPos = this.isXAxis ?\n                        e.point.axisXpos :\n                        this.len - e.point.axisYpos;\n                }\n            }\n        });\n        addEvent(Axis, 'destroy', function () {\n            ['backFrame', 'bottomFrame', 'sideFrame'].forEach(function (prop) {\n                if (this[prop]) {\n                    this[prop] = this[prop].destroy();\n                }\n            }, this);\n        });\n        /*\n        Z-AXIS\n         */\n        Chart.prototype.addZAxis = function (options) {\n            return new ZAxis(this, options);\n        };\n        Chart.prototype.collectionsWithUpdate.push('zAxis');\n        Chart.prototype.collectionsWithInit.zAxis = [Chart.prototype.addZAxis];\n        Axis.prototype.swapZ = function (p, insidePlotArea) {\n            if (this.isZAxis) {\n                var plotLeft = insidePlotArea ? 0 : this.chart.plotLeft;\n                return {\n                    x: plotLeft + p.z,\n                    y: p.y,\n                    z: p.x - plotLeft\n                };\n            }\n            return p;\n        };\n        ZAxis = H.ZAxis = function () {\n            this.init.apply(this, arguments);\n        };\n        extend(ZAxis.prototype, Axis.prototype);\n        extend(ZAxis.prototype, {\n            isZAxis: true,\n            setOptions: function (userOptions) {\n                userOptions = merge({\n                    offset: 0,\n                    lineWidth: 0\n                }, userOptions);\n                Axis.prototype.setOptions.call(this, userOptions);\n                this.coll = 'zAxis';\n            },\n            setAxisSize: function () {\n                Axis.prototype.setAxisSize.call(this);\n                this.width = this.len =\n                    this.chart.options.chart.options3d.depth;\n                this.right = this.chart.chartWidth - this.width - this.left;\n            },\n            getSeriesExtremes: function () {\n                var axis = this,\n                    chart = axis.chart;\n                axis.hasVisibleSeries = false;\n                // Reset properties in case we're redrawing (#3353)\n                axis.dataMin =\n                    axis.dataMax =\n                        axis.ignoreMinPadding =\n                            axis.ignoreMaxPadding = null;\n                if (axis.buildStacks) {\n                    axis.buildStacks();\n                }\n                // loop through this axis' series\n                axis.series.forEach(function (series) {\n                    if (series.visible ||\n                        !chart.options.chart.ignoreHiddenSeries) {\n                        var seriesOptions = series.options,\n                            zData,\n                            threshold = seriesOptions.threshold;\n                        axis.hasVisibleSeries = true;\n                        // Validate threshold in logarithmic axes\n                        if (axis.positiveValuesOnly && threshold <= 0) {\n                            threshold = null;\n                        }\n                        zData = series.zData;\n                        if (zData.length) {\n                            axis.dataMin = Math.min(pick(axis.dataMin, zData[0]), Math.min.apply(null, zData));\n                            axis.dataMax = Math.max(pick(axis.dataMax, zData[0]), Math.max.apply(null, zData));\n                        }\n                    }\n                });\n            }\n        });\n        // Get the Z axis in addition to the default X and Y.\n        addEvent(Chart, 'afterGetAxes', function () {\n            var chart = this,\n                options = this.options,\n                zAxisOptions = options.zAxis = splat(options.zAxis || {});\n            if (!chart.is3d()) {\n                return;\n            }\n            this.zAxis = [];\n            zAxisOptions.forEach(function (axisOptions, i) {\n                axisOptions.index = i;\n                // Z-Axis is shown horizontally, so it's kind of a X-Axis\n                axisOptions.isX = true;\n                var zAxis = chart.addZAxis(axisOptions);\n                zAxis.setScale();\n            });\n        });\n        // Wrap getSlotWidth function to calculate individual width value for each slot\n        // (#8042).\n        wrap(Axis.prototype, 'getSlotWidth', function (proceed, tick) {\n            if (this.chart.is3d() &&\n                tick &&\n                tick.label &&\n                this.categories &&\n                this.chart.frameShapes) {\n                var chart = this.chart,\n                    ticks = this.ticks,\n                    gridGroup = this.gridGroup.element.childNodes,\n                    firstGridLine = gridGroup[0].getBBox(),\n                    frame3DLeft = chart.frameShapes.left.getBBox(),\n                    options3d = chart.options.chart.options3d,\n                    origin = {\n                        x: chart.plotWidth / 2,\n                        y: chart.plotHeight / 2,\n                        z: options3d.depth / 2,\n                        vd: pick(options3d.depth, 1) * pick(options3d.viewDistance, 0)\n                    },\n                    labelPos,\n                    prevLabelPos,\n                    nextLabelPos,\n                    slotWidth,\n                    tickId = tick.pos,\n                    prevTick = ticks[tickId - 1],\n                    nextTick = ticks[tickId + 1];\n                // Check whether the tick is not the first one and previous tick exists,\n                // then calculate position of previous label.\n                if (tickId !== 0 && prevTick && prevTick.label.xy) { // #8621\n                    prevLabelPos = perspective3D({\n                        x: prevTick.label.xy.x,\n                        y: prevTick.label.xy.y,\n                        z: null\n                    }, origin, origin.vd);\n                }\n                // If next label position is defined, then recalculate its position\n                // basing on the perspective.\n                if (nextTick && nextTick.label.xy) {\n                    nextLabelPos = perspective3D({\n                        x: nextTick.label.xy.x,\n                        y: nextTick.label.xy.y,\n                        z: null\n                    }, origin, origin.vd);\n                }\n                labelPos = {\n                    x: tick.label.xy.x,\n                    y: tick.label.xy.y,\n                    z: null\n                };\n                labelPos = perspective3D(labelPos, origin, origin.vd);\n                // If tick is first one, check whether next label position is already\n                // calculated, then return difference between the first and the second\n                // label. If there is no next label position calculated, return the\n                // difference between the first grid line and left 3d frame.\n                slotWidth = Math.abs(prevLabelPos ?\n                    labelPos.x - prevLabelPos.x : nextLabelPos ?\n                    nextLabelPos.x - labelPos.x :\n                    firstGridLine.x - frame3DLeft.x);\n                return slotWidth;\n            }\n            return proceed.apply(this, [].slice.call(arguments, 1));\n        });\n\n    });\n    _registerModule(_modules, 'parts-3d/Series.js', [_modules['parts/Globals.js'], _modules['parts/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  (c) 2010-2019 Torstein Honsi\n         *\n         *  Extension to the Series object in 3D charts.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var pick = U.pick;\n        var addEvent = H.addEvent,\n            perspective = H.perspective;\n        /* eslint-disable no-invalid-this */\n        // Wrap the translate method to post-translate points into 3D perspective\n        addEvent(H.Series, 'afterTranslate', function () {\n            if (this.chart.is3d()) {\n                this.translate3dPoints();\n            }\n        });\n        // Translate the plotX, plotY properties and add plotZ.\n        H.Series.prototype.translate3dPoints = function () {\n            var series = this,\n                chart = series.chart,\n                zAxis = pick(series.zAxis,\n                chart.options.zAxis[0]),\n                rawPoints = [],\n                rawPoint,\n                projectedPoints,\n                projectedPoint,\n                zValue,\n                i;\n            for (i = 0; i < series.data.length; i++) {\n                rawPoint = series.data[i];\n                if (zAxis && zAxis.translate) {\n                    zValue = zAxis.isLog && zAxis.val2lin ?\n                        zAxis.val2lin(rawPoint.z) :\n                        rawPoint.z; // #4562\n                    rawPoint.plotZ = zAxis.translate(zValue);\n                    rawPoint.isInside = rawPoint.isInside ?\n                        (zValue >= zAxis.min &&\n                            zValue <= zAxis.max) :\n                        false;\n                }\n                else {\n                    rawPoint.plotZ = 0;\n                }\n                rawPoint.axisXpos = rawPoint.plotX;\n                rawPoint.axisYpos = rawPoint.plotY;\n                rawPoint.axisZpos = rawPoint.plotZ;\n                rawPoints.push({\n                    x: rawPoint.plotX,\n                    y: rawPoint.plotY,\n                    z: rawPoint.plotZ\n                });\n            }\n            projectedPoints = perspective(rawPoints, chart, true);\n            for (i = 0; i < series.data.length; i++) {\n                rawPoint = series.data[i];\n                projectedPoint = projectedPoints[i];\n                rawPoint.plotX = projectedPoint.x;\n                rawPoint.plotY = projectedPoint.y;\n                rawPoint.plotZ = projectedPoint.z;\n            }\n        };\n\n    });\n    _registerModule(_modules, 'parts-3d/Column.js', [_modules['parts/Globals.js'], _modules['parts/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  (c) 2010-2019 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var pick = U.pick,\n            wrap = U.wrap;\n        var addEvent = H.addEvent,\n            perspective = H.perspective,\n            Series = H.Series,\n            seriesTypes = H.seriesTypes,\n            svg = H.svg;\n        /**\n         * Depth of the columns in a 3D column chart.\n         *\n         * @type      {number}\n         * @default   25\n         * @since     4.0\n         * @product   highcharts\n         * @requires  highcharts-3d\n         * @apioption plotOptions.column.depth\n         */\n        /**\n         * 3D columns only. The color of the edges. Similar to `borderColor`, except it\n         * defaults to the same color as the column.\n         *\n         * @type      {Highcharts.ColorString}\n         * @product   highcharts\n         * @requires  highcharts-3d\n         * @apioption plotOptions.column.edgeColor\n         */\n        /**\n         * 3D columns only. The width of the colored edges.\n         *\n         * @type      {number}\n         * @default   1\n         * @product   highcharts\n         * @requires  highcharts-3d\n         * @apioption plotOptions.column.edgeWidth\n         */\n        /**\n         * The spacing between columns on the Z Axis in a 3D chart.\n         *\n         * @type      {number}\n         * @default   1\n         * @since     4.0\n         * @product   highcharts\n         * @requires  highcharts-3d\n         * @apioption plotOptions.column.groupZPadding\n         */\n        /* eslint-disable no-invalid-this */\n        wrap(seriesTypes.column.prototype, 'translate', function (proceed) {\n            proceed.apply(this, [].slice.call(arguments, 1));\n            // Do not do this if the chart is not 3D\n            if (this.chart.is3d()) {\n                this.translate3dShapes();\n            }\n        });\n        // In 3D we need to pass point.outsidePlot option to the justifyDataLabel\n        // method for disabling justifying dataLabels in columns outside plot\n        wrap(H.Series.prototype, 'alignDataLabel', function (proceed) {\n            arguments[3].outside3dPlot = arguments[1].outside3dPlot;\n            proceed.apply(this, [].slice.call(arguments, 1));\n        });\n        // Don't use justifyDataLabel when point is outsidePlot\n        wrap(H.Series.prototype, 'justifyDataLabel', function (proceed) {\n            return !(arguments[2].outside3dPlot) ?\n                proceed.apply(this, [].slice.call(arguments, 1)) :\n                false;\n        });\n        seriesTypes.column.prototype.translate3dPoints = function () { };\n        seriesTypes.column.prototype.translate3dShapes = function () {\n            var series = this,\n                chart = series.chart,\n                seriesOptions = series.options,\n                depth = seriesOptions.depth || 25,\n                stack = seriesOptions.stacking ?\n                    (seriesOptions.stack || 0) :\n                    series.index, // #4743\n                z = stack * (depth + (seriesOptions.groupZPadding || 1)),\n                borderCrisp = series.borderWidth % 2 ? 0.5 : 0;\n            if (chart.inverted && !series.yAxis.reversed) {\n                borderCrisp *= -1;\n            }\n            if (seriesOptions.grouping !== false) {\n                z = 0;\n            }\n            z += (seriesOptions.groupZPadding || 1);\n            series.data.forEach(function (point) {\n                // #7103 Reset outside3dPlot flag\n                point.outside3dPlot = null;\n                if (point.y !== null) {\n                    var shapeArgs = point.shapeArgs, tooltipPos = point.tooltipPos, \n                        // Array for final shapeArgs calculation.\n                        // We are checking two dimensions (x and y).\n                        dimensions = [['x', 'width'], ['y', 'height']], borderlessBase; // Crisped rects can have +/- 0.5 pixels offset.\n                        // #3131 We need to check if column is inside plotArea.\n                        dimensions.forEach(function (d) {\n                            borderlessBase = shapeArgs[d[0]] - borderCrisp;\n                        if (borderlessBase < 0) {\n                            // If borderLessBase is smaller than 0, it is needed to set\n                            // its value to 0 or 0.5 depending on borderWidth\n                            // borderWidth may be even or odd.\n                            shapeArgs[d[1]] +=\n                                shapeArgs[d[0]] + borderCrisp;\n                            shapeArgs[d[0]] = -borderCrisp;\n                            borderlessBase = 0;\n                        }\n                        if ((borderlessBase + shapeArgs[d[1]] >\n                            series[d[0] + 'Axis'].len) &&\n                            // Do not change height/width of column if 0 (#6708)\n                            shapeArgs[d[1]] !== 0) {\n                            shapeArgs[d[1]] =\n                                series[d[0] + 'Axis'].len -\n                                    shapeArgs[d[0]];\n                        }\n                        if (\n                        // Do not remove columns with zero height/width.\n                        (shapeArgs[d[1]] !== 0) &&\n                            (shapeArgs[d[0]] >=\n                                series[d[0] + 'Axis'].len ||\n                                shapeArgs[d[0]] + shapeArgs[d[1]] <=\n                                    borderCrisp)) {\n                            // Set args to 0 if column is outside the chart.\n                            for (var key in shapeArgs) { // eslint-disable-line guard-for-in\n                                shapeArgs[key] = 0;\n                            }\n                            // #7103 outside3dPlot flag is set on Points which are\n                            // currently outside of plot.\n                            point.outside3dPlot = true;\n                        }\n                    });\n                    // Change from 2d to 3d\n                    if (point.shapeType === 'rect') {\n                        point.shapeType = 'cuboid';\n                    }\n                    shapeArgs.z = z;\n                    shapeArgs.depth = depth;\n                    shapeArgs.insidePlotArea = true;\n                    // Translate the tooltip position in 3d space\n                    tooltipPos = perspective([{\n                            x: tooltipPos[0],\n                            y: tooltipPos[1],\n                            z: z\n                        }], chart, true)[0];\n                    point.tooltipPos = [tooltipPos.x, tooltipPos.y];\n                }\n            });\n            // store for later use #4067\n            series.z = z;\n        };\n        wrap(seriesTypes.column.prototype, 'animate', function (proceed) {\n            if (!this.chart.is3d()) {\n                proceed.apply(this, [].slice.call(arguments, 1));\n            }\n            else {\n                var args = arguments,\n                    init = args[1],\n                    yAxis = this.yAxis,\n                    series = this,\n                    reversed = this.yAxis.reversed;\n                if (svg) { // VML is too slow anyway\n                    if (init) {\n                        series.data.forEach(function (point) {\n                            if (point.y !== null) {\n                                point.height = point.shapeArgs.height;\n                                point.shapey = point.shapeArgs.y; // #2968\n                                point.shapeArgs.height = 1;\n                                if (!reversed) {\n                                    if (point.stackY) {\n                                        point.shapeArgs.y =\n                                            point.plotY +\n                                                yAxis.translate(point.stackY);\n                                    }\n                                    else {\n                                        point.shapeArgs.y =\n                                            point.plotY +\n                                                (point.negative ?\n                                                    -point.height :\n                                                    point.height);\n                                    }\n                                }\n                            }\n                        });\n                    }\n                    else { // run the animation\n                        series.data.forEach(function (point) {\n                            if (point.y !== null) {\n                                point.shapeArgs.height = point.height;\n                                point.shapeArgs.y = point.shapey; // #2968\n                                // null value do not have a graphic\n                                if (point.graphic) {\n                                    point.graphic.animate(point.shapeArgs, series.options.animation);\n                                }\n                            }\n                        });\n                        // redraw datalabels to the correct position\n                        this.drawDataLabels();\n                        // delete this function to allow it only once\n                        series.animate = null;\n                    }\n                }\n            }\n        });\n        // In case of 3d columns there is no sense to add this columns to a specific\n        // series group - if series is added to a group all columns will have the same\n        // zIndex in comparison with different series.\n        wrap(seriesTypes.column.prototype, 'plotGroup', function (proceed, prop, name, visibility, zIndex, parent) {\n            if (prop !== 'dataLabelsGroup') {\n                if (this.chart.is3d()) {\n                    if (this[prop]) {\n                        delete this[prop];\n                    }\n                    if (parent) {\n                        if (!this.chart.columnGroup) {\n                            this.chart.columnGroup =\n                                this.chart.renderer.g('columnGroup').add(parent);\n                        }\n                        this[prop] = this.chart.columnGroup;\n                        this.chart.columnGroup.attr(this.getPlotBox());\n                        this[prop].survive = true;\n                        if (prop === 'group' || prop === 'markerGroup') {\n                            arguments[3] = 'visible';\n                            // For 3D column group and markerGroup should be visible\n                        }\n                    }\n                }\n            }\n            return proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n        });\n        // When series is not added to group it is needed to change setVisible method to\n        // allow correct Legend funcionality. This wrap is basing on pie chart series.\n        wrap(seriesTypes.column.prototype, 'setVisible', function (proceed, vis) {\n            var series = this,\n                pointVis;\n            if (series.chart.is3d()) {\n                series.data.forEach(function (point) {\n                    point.visible = point.options.visible = vis =\n                        typeof vis === 'undefined' ?\n                            !pick(series.visible, point.visible) : vis;\n                    pointVis = vis ? 'visible' : 'hidden';\n                    series.options.data[series.data.indexOf(point)] =\n                        point.options;\n                    if (point.graphic) {\n                        point.graphic.attr({\n                            visibility: pointVis\n                        });\n                    }\n                });\n            }\n            proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n        });\n        seriesTypes.column.prototype\n            .handle3dGrouping = true;\n        addEvent(Series, 'afterInit', function () {\n            if (this.chart.is3d() &&\n                this.handle3dGrouping) {\n                var seriesOptions = this.options,\n                    grouping = seriesOptions.grouping,\n                    stacking = seriesOptions.stacking,\n                    reversedStacks = pick(this.yAxis.options.reversedStacks,\n                    true),\n                    z = 0;\n                // @todo grouping === true ?\n                if (!(typeof grouping !== 'undefined' && !grouping)) {\n                    var stacks = this.chart.retrieveStacks(stacking),\n                        stack = seriesOptions.stack || 0,\n                        i; // position within the stack\n                        for (i = 0; i < stacks[stack].series.length; i++) {\n                            if (stacks[stack].series[i] === this) {\n                                break;\n                        }\n                    }\n                    z = (10 * (stacks.totalStacks - stacks[stack].position)) +\n                        (reversedStacks ? i : -i); // #4369\n                    // In case when axis is reversed, columns are also reversed inside\n                    // the group (#3737)\n                    if (!this.xAxis.reversed) {\n                        z = (stacks.totalStacks * 10) - z;\n                    }\n                }\n                seriesOptions.zIndex = z;\n            }\n        });\n        // eslint-disable-next-line valid-jsdoc\n        /**\n         * @private\n         */\n        function pointAttribs(proceed) {\n            var attr = proceed.apply(this,\n                [].slice.call(arguments, 1));\n            if (this.chart.is3d && this.chart.is3d()) {\n                // Set the fill color to the fill color to provide a smooth edge\n                attr.stroke = this.options.edgeColor || attr.fill;\n                attr['stroke-width'] = pick(this.options.edgeWidth, 1); // #4055\n            }\n            return attr;\n        }\n        // eslint-disable-next-line valid-jsdoc\n        /**\n         * In 3D mode, all column-series are rendered in one main group. Because of that\n         * we need to apply inactive state on all points.\n         * @private\n         */\n        function setState(proceed, state, inherit) {\n            var is3d = this.chart.is3d && this.chart.is3d();\n            if (is3d) {\n                this.options.inactiveOtherPoints = true;\n            }\n            proceed.call(this, state, inherit);\n            if (is3d) {\n                this.options.inactiveOtherPoints = false;\n            }\n        }\n        // eslint-disable-next-line valid-jsdoc\n        /**\n         * In 3D mode, simple checking for a new shape to animate is not enough.\n         * Additionally check if graphic is a group of elements\n         * @private\n         */\n        function hasNewShapeType(proceed) {\n            var args = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n            }\n            return this.series.chart.is3d() ?\n                this.graphic && this.graphic.element.nodeName !== 'g' :\n                proceed.apply(this, args);\n        }\n        wrap(seriesTypes.column.prototype, 'pointAttribs', pointAttribs);\n        wrap(seriesTypes.column.prototype, 'setState', setState);\n        wrap(seriesTypes.column.prototype.pointClass.prototype, 'hasNewShapeType', hasNewShapeType);\n        if (seriesTypes.columnrange) {\n            wrap(seriesTypes.columnrange.prototype, 'pointAttribs', pointAttribs);\n            wrap(seriesTypes.columnrange.prototype, 'setState', setState);\n            wrap(seriesTypes.columnrange.prototype.pointClass.prototype, 'hasNewShapeType', hasNewShapeType);\n            seriesTypes.columnrange.prototype.plotGroup =\n                seriesTypes.column.prototype.plotGroup;\n            seriesTypes.columnrange.prototype.setVisible =\n                seriesTypes.column.prototype.setVisible;\n        }\n        wrap(Series.prototype, 'alignDataLabel', function (proceed) {\n            // Only do this for 3D columns and it's derived series\n            if (this.chart.is3d() &&\n                this instanceof seriesTypes.column) {\n                var series = this,\n                    chart = series.chart;\n                var args = arguments,\n                    alignTo = args[4],\n                    point = args[1];\n                var pos = ({ x: alignTo.x,\n                    y: alignTo.y,\n                    z: series.z });\n                pos = perspective([pos], chart, true)[0];\n                alignTo.x = pos.x;\n                // #7103 If point is outside of plotArea, hide data label.\n                alignTo.y = point.outside3dPlot ? -9e9 : pos.y;\n            }\n            proceed.apply(this, [].slice.call(arguments, 1));\n        });\n        // Added stackLabels position calculation for 3D charts.\n        wrap(H.StackItem.prototype, 'getStackBox', function (proceed, chart) {\n            var stackBox = proceed.apply(this,\n                [].slice.call(arguments, 1));\n            // Only do this for 3D chart.\n            if (chart.is3d()) {\n                var pos = ({\n                        x: stackBox.x,\n                        y: stackBox.y,\n                        z: 0\n                    });\n                pos = H.perspective([pos], chart, true)[0];\n                stackBox.x = pos.x;\n                stackBox.y = pos.y;\n            }\n            return stackBox;\n        });\n\n    });\n    _registerModule(_modules, 'parts-3d/Pie.js', [_modules['parts/Globals.js'], _modules['parts/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  (c) 2010-2019 Torstein Honsi\n         *\n         *  3D pie series\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var pick = U.pick,\n            wrap = U.wrap;\n        var deg2rad = H.deg2rad,\n            seriesTypes = H.seriesTypes,\n            svg = H.svg;\n        /**\n         * The thickness of a 3D pie.\n         *\n         * @type      {number}\n         * @default   0\n         * @since     4.0\n         * @product   highcharts\n         * @requires  highcharts-3d\n         * @apioption plotOptions.pie.depth\n         */\n        /* eslint-disable no-invalid-this */\n        wrap(seriesTypes.pie.prototype, 'translate', function (proceed) {\n            proceed.apply(this, [].slice.call(arguments, 1));\n            // Do not do this if the chart is not 3D\n            if (!this.chart.is3d()) {\n                return;\n            }\n            var series = this,\n                seriesOptions = series.options,\n                depth = seriesOptions.depth || 0,\n                options3d = series.chart.options.chart.options3d,\n                alpha = options3d.alpha,\n                beta = options3d.beta,\n                z = seriesOptions.stacking ?\n                    (seriesOptions.stack || 0) * depth :\n                    series._i * depth;\n            z += depth / 2;\n            if (seriesOptions.grouping !== false) {\n                z = 0;\n            }\n            series.data.forEach(function (point) {\n                var shapeArgs = point.shapeArgs,\n                    angle;\n                point.shapeType = 'arc3d';\n                shapeArgs.z = z;\n                shapeArgs.depth = depth * 0.75;\n                shapeArgs.alpha = alpha;\n                shapeArgs.beta = beta;\n                shapeArgs.center = series.center;\n                angle = (shapeArgs.end + shapeArgs.start) / 2;\n                point.slicedTranslation = {\n                    translateX: Math.round(Math.cos(angle) *\n                        seriesOptions.slicedOffset *\n                        Math.cos(alpha * deg2rad)),\n                    translateY: Math.round(Math.sin(angle) *\n                        seriesOptions.slicedOffset *\n                        Math.cos(alpha * deg2rad))\n                };\n            });\n        });\n        wrap(seriesTypes.pie.prototype.pointClass.prototype, 'haloPath', function (proceed) {\n            var args = arguments;\n            return this.series.chart.is3d() ? [] : proceed.call(this, args[1]);\n        });\n        wrap(seriesTypes.pie.prototype, 'pointAttribs', function (proceed, point, state) {\n            var attr = proceed.call(this,\n                point,\n                state),\n                options = this.options;\n            if (this.chart.is3d() && !this.chart.styledMode) {\n                attr.stroke = options.edgeColor || point.color || this.color;\n                attr['stroke-width'] = pick(options.edgeWidth, 1);\n            }\n            return attr;\n        });\n        wrap(seriesTypes.pie.prototype, 'drawDataLabels', function (proceed) {\n            if (this.chart.is3d()) {\n                var series = this,\n                    chart = series.chart,\n                    options3d = chart.options.chart.options3d;\n                series.data.forEach(function (point) {\n                    var shapeArgs = point.shapeArgs,\n                        r = shapeArgs.r, \n                        // #3240 issue with datalabels for 0 and null values\n                        a1 = (shapeArgs.alpha || options3d.alpha) * deg2rad,\n                        b1 = (shapeArgs.beta || options3d.beta) * deg2rad,\n                        a2 = (shapeArgs.start + shapeArgs.end) / 2,\n                        labelPosition = point.labelPosition,\n                        connectorPosition = labelPosition.connectorPosition,\n                        yOffset = (-r * (1 - Math.cos(a1)) * Math.sin(a2)),\n                        xOffset = r * (Math.cos(b1) - 1) * Math.cos(a2);\n                    // Apply perspective on label positions\n                    [\n                        labelPosition.natural,\n                        connectorPosition.breakAt,\n                        connectorPosition.touchingSliceAt\n                    ].forEach(function (coordinates) {\n                        coordinates.x += xOffset;\n                        coordinates.y += yOffset;\n                    });\n                });\n            }\n            proceed.apply(this, [].slice.call(arguments, 1));\n        });\n        wrap(seriesTypes.pie.prototype, 'addPoint', function (proceed) {\n            proceed.apply(this, [].slice.call(arguments, 1));\n            if (this.chart.is3d()) {\n                // destroy (and rebuild) everything!!!\n                this.update(this.userOptions, true); // #3845 pass the old options\n            }\n        });\n        wrap(seriesTypes.pie.prototype, 'animate', function (proceed) {\n            if (!this.chart.is3d()) {\n                proceed.apply(this, [].slice.call(arguments, 1));\n            }\n            else {\n                var args = arguments,\n                    init = args[1],\n                    animation = this.options.animation,\n                    attribs,\n                    center = this.center,\n                    group = this.group,\n                    markerGroup = this.markerGroup;\n                if (svg) { // VML is too slow anyway\n                    if (animation === true) {\n                        animation = {};\n                    }\n                    // Initialize the animation\n                    if (init) {\n                        // Scale down the group and place it in the center\n                        group.oldtranslateX = group.translateX;\n                        group.oldtranslateY = group.translateY;\n                        attribs = {\n                            translateX: center[0],\n                            translateY: center[1],\n                            scaleX: 0.001,\n                            scaleY: 0.001\n                        };\n                        group.attr(attribs);\n                        if (markerGroup) {\n                            markerGroup.attrSetters = group.attrSetters;\n                            markerGroup.attr(attribs);\n                        }\n                        // Run the animation\n                    }\n                    else {\n                        attribs = {\n                            translateX: group.oldtranslateX,\n                            translateY: group.oldtranslateY,\n                            scaleX: 1,\n                            scaleY: 1\n                        };\n                        group.animate(attribs, animation);\n                        if (markerGroup) {\n                            markerGroup.animate(attribs, animation);\n                        }\n                        // Delete this function to allow it only once\n                        this.animate = null;\n                    }\n                }\n            }\n        });\n\n    });\n    _registerModule(_modules, 'parts-3d/Scatter.js', [_modules['parts/Globals.js']], function (H) {\n        /* *\n         *\n         *  (c) 2010-2019 Torstein Honsi\n         *\n         *  Scatter 3D series.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var Point = H.Point,\n            seriesType = H.seriesType,\n            seriesTypes = H.seriesTypes;\n        /**\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.scatter3d\n         *\n         * @augments Highcharts.Series\n         */\n        seriesType('scatter3d', 'scatter', \n        /**\n         * A 3D scatter plot uses x, y and z coordinates to display values for three\n         * variables for a set of data.\n         *\n         * @sample {highcharts} highcharts/3d/scatter/\n         *         Simple 3D scatter\n         * @sample {highcharts} highcharts/demo/3d-scatter-draggable\n         *         Draggable 3d scatter\n         *\n         * @extends      plotOptions.scatter\n         * @excluding    dragDrop, cluster\n         * @product      highcharts\n         * @requires     highcharts-3d\n         * @optionparent plotOptions.scatter3d\n         */\n        {\n            tooltip: {\n                pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>z: <b>{point.z}</b><br/>'\n            }\n            // Series class\n        }, {\n            pointAttribs: function (point) {\n                var attribs = seriesTypes.scatter.prototype.pointAttribs\n                        .apply(this,\n                    arguments);\n                if (this.chart.is3d() && point) {\n                    attribs.zIndex =\n                        H.pointCameraDistance(point, this.chart);\n                }\n                return attribs;\n            },\n            axisTypes: ['xAxis', 'yAxis', 'zAxis'],\n            pointArrayMap: ['x', 'y', 'z'],\n            parallelArrays: ['x', 'y', 'z'],\n            // Require direct touch rather than using the k-d-tree, because the\n            // k-d-tree currently doesn't take the xyz coordinate system into\n            // account (#4552)\n            directTouch: true\n            // Point class\n        }, {\n            applyOptions: function () {\n                Point.prototype.applyOptions.apply(this, arguments);\n                if (typeof this.z === 'undefined') {\n                    this.z = 0;\n                }\n                return this;\n            }\n        });\n        /**\n         * A `scatter3d` series. If the [type](#series.scatter3d.type) option is\n         * not specified, it is inherited from [chart.type](#chart.type).\n         *\n         * scatter3d](#plotOptions.scatter3d).\n         *\n         * @extends   series,plotOptions.scatter3d\n         * @product   highcharts\n         * @requires  highcharts-3d\n         * @apioption series.scatter3d\n         */\n        /**\n         * An array of data points for the series. For the `scatter3d` series\n         * type, points can be given in the following ways:\n         *\n         * 1.  An array of arrays with 3 values. In this case, the values correspond\n         * to `x,y,z`. If the first value is a string, it is applied as the name\n         * of the point, and the `x` value is inferred.\n         *\n         *  ```js\n         *     data: [\n         *         [0, 0, 1],\n         *         [1, 8, 7],\n         *         [2, 9, 2]\n         *     ]\n         *  ```\n         *\n         * 3.  An array of objects with named values. The following snippet shows only a\n         * few settings, see the complete options set below. If the total number of data\n         * points exceeds the series'\n         * [turboThreshold](#series.scatter3d.turboThreshold), this option is not\n         * available.\n         *\n         *  ```js\n         *     data: [{\n         *         x: 1,\n         *         y: 2,\n         *         z: 24,\n         *         name: \"Point2\",\n         *         color: \"#00FF00\"\n         *     }, {\n         *         x: 1,\n         *         y: 4,\n         *         z: 12,\n         *         name: \"Point1\",\n         *         color: \"#FF00FF\"\n         *     }]\n         *  ```\n         *\n         * @sample {highcharts} highcharts/chart/reflow-true/\n         *         Numerical values\n         * @sample {highcharts} highcharts/series/data-array-of-arrays/\n         *         Arrays of numeric x and y\n         * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n         *         Arrays of datetime x and y\n         * @sample {highcharts} highcharts/series/data-array-of-name-value/\n         *         Arrays of point.name and y\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @type      {Array<Array<number>|*>}\n         * @extends   series.scatter.data\n         * @product   highcharts\n         * @apioption series.scatter3d.data\n         */\n        /**\n         * The z value for each data point.\n         *\n         * @type      {number}\n         * @product   highcharts\n         * @apioption series.scatter3d.data.z\n         */\n        ''; // adds doclets above to transpiled file\n\n    });\n    _registerModule(_modules, 'parts-3d/VMLRenderer.js', [_modules['parts/Globals.js']], function (H) {\n        /* *\n         *\n         *  (c) 2010-2019 Torstein Honsi\n         *\n         *  Extension to the VML Renderer\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var addEvent = H.addEvent,\n            Axis = H.Axis,\n            SVGRenderer = H.SVGRenderer,\n            VMLRenderer = H.VMLRenderer;\n        if (VMLRenderer) {\n            H.setOptions({ animate: false });\n            VMLRenderer.prototype.face3d = SVGRenderer.prototype.face3d;\n            VMLRenderer.prototype.polyhedron = SVGRenderer.prototype.polyhedron;\n            VMLRenderer.prototype.elements3d = SVGRenderer.prototype.elements3d;\n            VMLRenderer.prototype.element3d = SVGRenderer.prototype.element3d;\n            VMLRenderer.prototype.cuboid = SVGRenderer.prototype.cuboid;\n            VMLRenderer.prototype.cuboidPath = SVGRenderer.prototype.cuboidPath;\n            VMLRenderer.prototype.toLinePath = SVGRenderer.prototype.toLinePath;\n            VMLRenderer.prototype.toLineSegments = SVGRenderer.prototype.toLineSegments;\n            VMLRenderer.prototype.arc3d = function (shapeArgs) {\n                var result = SVGRenderer.prototype.arc3d.call(this,\n                    shapeArgs);\n                result.css({ zIndex: result.zIndex });\n                return result;\n            };\n            H.VMLRenderer.prototype.arc3dPath = H.SVGRenderer.prototype.arc3dPath;\n            /* eslint-disable no-invalid-this */\n            addEvent(Axis, 'render', function () {\n                // VML doesn't support a negative z-index\n                if (this.sideFrame) {\n                    this.sideFrame.css({ zIndex: 0 });\n                    this.sideFrame.front.attr({\n                        fill: this.sideFrame.color\n                    });\n                }\n                if (this.bottomFrame) {\n                    this.bottomFrame.css({ zIndex: 1 });\n                    this.bottomFrame.front.attr({\n                        fill: this.bottomFrame.color\n                    });\n                }\n                if (this.backFrame) {\n                    this.backFrame.css({ zIndex: 0 });\n                    this.backFrame.front.attr({\n                        fill: this.backFrame.color\n                    });\n                }\n            });\n            /* eslint-enable no-invalid-this */\n        }\n\n    });\n    _registerModule(_modules, 'masters/highcharts-3d.src.js', [], function () {\n\n\n    });\n}));"],"sourceRoot":""}